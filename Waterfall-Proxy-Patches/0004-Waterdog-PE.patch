From b7b893aef4b3a2dd5f1a4033c161e02080d6582c Mon Sep 17 00:00:00 2001
From: Colin Godsey <crgodsey@gmail.com>
Date: Mon, 15 Apr 2019 18:28:46 -0600
Subject: [PATCH] Waterdog PE


diff --git a/README.md b/README.md
index ef9b6f70..1c09e81c 100644
--- a/README.md
+++ b/README.md
@@ -1,13 +1,16 @@
-BungeeCord
+Waterdog
 ==========
-Layer 7 proxy designed to link Minecraft servers.
+~~[BungeeCord](https://github.com/SpigotMC/BungeeCord)~~ [Waterfall](https://github.com/PaperMC/Waterfall) fork designed to link Minecraft servers.
 --------------------------------------------------
 
-BungeeCord is a sophisticated proxy and API designed mainly to teleport players between multiple Minecraft servers. It is the latest incarnation of similar software written by the author from 2011-present.
+This fork provides native support for the Minecraft Bedrock protocols along with the existing java protocols.
+It is capable of using the ProtocolSupport encapsulation protocol for PSPE support, or it
+can use the native RakNet Bedrock protocol for traditional downstream Bedrock servers such as
+Nukkit, Pocketmine, MiNET, and others. 
 
 Information
 -----------
-BungeeCord is maintained by [SpigotMC](https://www.spigotmc.org/) and has its own [discussion thread](https://www.spigotmc.org/go/bungeecord) with plenty of helpful information and links.
+Please refer to the existing [BungeeCord](https://github.com/SpigotMC/BungeeCord) and [Waterfall](https://github.com/PaperMC/Waterfall) documentation for core functionality.
 
 ### Security warning
 
@@ -17,10 +20,13 @@ To combat this, you need to restrict access to these servers for example with a
 
 Source
 ------
-Source code is currently available on [GitHub](https://www.spigotmc.org/go/bungeecord-git).
+Source code is currently available on [GitHub](https://github.com/yesdog/Waterdog).
+
+Contributing
+------
+We will not accept direct changes to this repo, it exists just for distribution. Instead, follow the contribution guidelines at our [Waterfall fork](https://github.com/yesdog/Waterfall).
 
 Binaries
 --------
-Precompiled binaries are available for end users on [Jenkins](https://www.spigotmc.org/go/bungeecord-dl).
+Precompiled binaries are available for end users on *coming soon*.
 
-(c) 2012-2018 SpigotMC Pty. Ltd.
diff --git a/api/src/main/java/net/md_5/bungee/api/ProxyServer.java b/api/src/main/java/net/md_5/bungee/api/ProxyServer.java
index 4965b234..1c6e3de3 100644
--- a/api/src/main/java/net/md_5/bungee/api/ProxyServer.java
+++ b/api/src/main/java/net/md_5/bungee/api/ProxyServer.java
@@ -221,7 +221,13 @@ public abstract class ProxyServer
      * @param restricted whether the server info restricted property will be set
      * @return the constructed instance
      */
-    public abstract ServerInfo constructServerInfo(String name, InetSocketAddress address, String motd, boolean restricted);
+    // Waterdog start
+    public abstract ServerInfo constructServerInfo(String name, InetSocketAddress address, String motd, boolean restricted, boolean useEncap);
+
+    public ServerInfo constructServerInfo(String name, InetSocketAddress address, String motd, boolean restricted) {
+        return constructServerInfo(name, address, motd, restricted, true);
+    }
+    // Waterdog end
 
     /**
      * Returns the console overlord for this proxy. Being the console, this
diff --git a/api/src/main/java/net/md_5/bungee/api/config/ListenerInfo.java b/api/src/main/java/net/md_5/bungee/api/config/ListenerInfo.java
index 42b84063..8d0f9574 100644
--- a/api/src/main/java/net/md_5/bungee/api/config/ListenerInfo.java
+++ b/api/src/main/java/net/md_5/bungee/api/config/ListenerInfo.java
@@ -71,13 +71,26 @@ public class ListenerInfo
      * Whether to support HAProxy PROXY protocol.
      */
     private final boolean proxyProtocol;
+    // Waterdog start
+    /**
+     * Whether this listener is a PE listener.
+     */
+    private final boolean peListener;
+    // Waterdog end
 
     @Deprecated
     public ListenerInfo(InetSocketAddress host, String motd, int maxPlayers, int tabListSize, List<String> serverPriority, boolean forceDefault, Map<String, String> forcedHosts, String tabListType, boolean setLocalAddress, boolean pingPassthrough, int queryPort, boolean queryEnabled)
     {
-        this( host, motd, maxPlayers, tabListSize, serverPriority, forceDefault, forcedHosts, tabListType, setLocalAddress, pingPassthrough, queryPort, queryEnabled, false );
+        this( host, motd, maxPlayers, tabListSize, serverPriority, forceDefault, forcedHosts, tabListType, setLocalAddress, pingPassthrough, queryPort, queryEnabled, false, false); // Waterdog
     }
 
+    // Waterdog start
+    public ListenerInfo(InetSocketAddress host, String motd, int maxPlayers, int tabListSize, List<String> serverPriority, boolean forceDefault, Map<String, String> forcedHosts, String tabListType, boolean setLocalAddress, boolean pingPassthrough, int queryPort, boolean queryEnabled, boolean proxyProtocol)
+    {
+        this( host, motd, maxPlayers, tabListSize, serverPriority, forceDefault, forcedHosts, tabListType, setLocalAddress, pingPassthrough, queryPort, queryEnabled, proxyProtocol, false );
+    }
+    // Waterdog end
+
     /**
      * Gets the highest priority server to join.
      *
@@ -102,4 +115,10 @@ public class ListenerInfo
     {
         return ( serverPriority.size() > 1 ) ? serverPriority.get( 1 ) : getDefaultServer();
     }
+
+    // Waterdog start
+    public boolean needsRealQuery() {
+        return queryEnabled && (!peListener || queryPort != host.getPort());
+    }
+    // Waterdog end
 }
diff --git a/native/src/main/java/net/md_5/bungee/jni/cipher/JavaCipher.java b/native/src/main/java/net/md_5/bungee/jni/cipher/JavaCipher.java
index 7b2249f8..94b1d42b 100644
--- a/native/src/main/java/net/md_5/bungee/jni/cipher/JavaCipher.java
+++ b/native/src/main/java/net/md_5/bungee/jni/cipher/JavaCipher.java
@@ -7,6 +7,7 @@ import javax.crypto.SecretKey;
 import javax.crypto.ShortBufferException;
 import javax.crypto.spec.IvParameterSpec;
 import java.security.GeneralSecurityException;
+import java.util.Arrays;
 
 public class JavaCipher implements BungeeCipher
 {
@@ -34,7 +35,7 @@ public class JavaCipher implements BungeeCipher
     public void init(boolean forEncryption, SecretKey key) throws GeneralSecurityException
     {
         int mode = forEncryption ? Cipher.ENCRYPT_MODE : Cipher.DECRYPT_MODE;
-        cipher.init( mode, key, new IvParameterSpec( key.getEncoded() ) );
+        cipher.init( mode, key, new IvParameterSpec( Arrays.copyOf(key.getEncoded(), 16) ) ); // Waterdog
     }
 
     @Override
diff --git a/protocol/pom.xml b/protocol/pom.xml
index f53ace34..41d84300 100644
--- a/protocol/pom.xml
+++ b/protocol/pom.xml
@@ -34,6 +34,18 @@
     </repositories>
 
     <dependencies>
+        <!-- Waterdog start -->
+        <dependency>
+            <groupId>com.nimbusds</groupId>
+            <artifactId>nimbus-jose-jwt</artifactId>
+            <version>5.2</version>
+        </dependency>
+        <dependency>
+            <groupId>org.apache.commons</groupId>
+            <artifactId>commons-lang3</artifactId>
+            <version>3.0</version>
+        </dependency>
+        <!-- Waterdog end -->
         <dependency>
             <groupId>net.md-5</groupId>
             <artifactId>brigadier</artifactId>
diff --git a/protocol/src/main/java/net/md_5/bungee/protocol/AbstractPacketHandler.java b/protocol/src/main/java/net/md_5/bungee/protocol/AbstractPacketHandler.java
index bef7b370..fabe6199 100644
--- a/protocol/src/main/java/net/md_5/bungee/protocol/AbstractPacketHandler.java
+++ b/protocol/src/main/java/net/md_5/bungee/protocol/AbstractPacketHandler.java
@@ -35,6 +35,11 @@ import net.md_5.bungee.protocol.packet.StatusRequest;
 import net.md_5.bungee.protocol.packet.StatusResponse;
 import net.md_5.bungee.protocol.packet.TabCompleteResponse;
 import net.md_5.bungee.protocol.packet.Title;
+import network.ycc.waterdog.pe.packet.PECommand;
+import network.ycc.waterdog.pe.packet.PEResourcePack;
+import network.ycc.waterdog.pe.packet.PEResourcePackResponse;
+import network.ycc.waterdog.pe.packet.PEResourceStack;
+import network.ycc.waterdog.pe.packet.PEEncryptionRequest;
 
 public abstract class AbstractPacketHandler
 {
@@ -180,4 +185,26 @@ public abstract class AbstractPacketHandler
     {
     }
     // Waterfall end
+
+    // Waterdog start
+    public void handle(PEResourcePack resourcePack) throws Exception
+    {
+    }
+
+    public void handle(PEResourceStack resourceStock) throws Exception
+    {
+    }
+
+    public void handle(PECommand command) throws Exception
+    {
+    }
+
+    public void handle(PEEncryptionRequest encryptionRequest) throws Exception
+    {
+    }
+
+    public void handle(PEResourcePackResponse resourcePackResponse) throws Exception
+    {
+    }
+    // Waterdog end
 }
diff --git a/protocol/src/main/java/net/md_5/bungee/protocol/DefinedPacket.java b/protocol/src/main/java/net/md_5/bungee/protocol/DefinedPacket.java
index ae09f50c..a2ebca9b 100644
--- a/protocol/src/main/java/net/md_5/bungee/protocol/DefinedPacket.java
+++ b/protocol/src/main/java/net/md_5/bungee/protocol/DefinedPacket.java
@@ -11,6 +11,55 @@ import java.util.UUID;
 @RequiredArgsConstructor
 public abstract class DefinedPacket
 {
+    // Waterdog start
+    public static void writeVarLong(ByteBuf to, long varlong) {
+        while ((varlong & 0xFFFFFFFFFFFFFF80L) != 0x0L) {
+            to.writeByte((int) (varlong & 0x7FL) | 0x80);
+            varlong >>>= 7;
+        }
+        to.writeByte((int) varlong);
+    }
+
+    public static long readSVarLong(ByteBuf from) {
+        long varlong = readVarLong(from);
+        return (varlong >> 1) ^ -(varlong & 1);
+    }
+
+    public static void writeSVarLong(ByteBuf to, long varlong) {
+        writeVarLong(to, (varlong << 1) ^ (varlong >> 63));
+    }
+
+    public static long readVarLong(ByteBuf from) {
+        long varlong = 0L;
+        int length = 0;
+        byte part;
+        do {
+            part = from.readByte();
+            varlong |= (part & 0x7F) << (length++ * 7);
+            if (length > 10) {
+                throw new RuntimeException("VarLong too big");
+            }
+        } while ((part & 0x80) == 0x80);
+        return varlong;
+    }
+
+    public static int readSVarInt(ByteBuf from) {
+        int varint = readVarInt(from);
+        return (varint >> 1) ^ -(varint & 1);
+    }
+
+    public static void writeVarInt(ByteBuf to, int i) {
+        while ((i & 0xFFFFFF80) != 0x0) {
+            to.writeByte(i | 0x80);
+            i >>>= 7;
+        }
+        to.writeByte(i);
+    }
+
+    public static void writeSVarInt(ByteBuf to, int varint) {
+        writeVarInt(to, (varint << 1) ^ (varint >> 31));
+    }
+    // Waterdog end
 
     public static void writeString(String s, ByteBuf buf)
     {
diff --git a/protocol/src/main/java/net/md_5/bungee/protocol/MinecraftDecoder.java b/protocol/src/main/java/net/md_5/bungee/protocol/MinecraftDecoder.java
index 01997098..95a39c45 100644
--- a/protocol/src/main/java/net/md_5/bungee/protocol/MinecraftDecoder.java
+++ b/protocol/src/main/java/net/md_5/bungee/protocol/MinecraftDecoder.java
@@ -36,10 +36,21 @@ public class MinecraftDecoder extends MessageToMessageDecoder<ByteBuf>
     }
 
     @Override
-    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception
-    {
-        Protocol.DirectionData prot = ( server ) ? protocol.TO_SERVER : protocol.TO_CLIENT;
-        ByteBuf slice = in.copy(); // Can't slice this one due to EntityMap :(
+    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) throws Exception {
+        Protocol.DirectionData prot = (server) ? protocol.TO_SERVER : protocol.TO_CLIENT;
+        //Waterdog start - replace in.copy()
+        //ByteBuf slice = in.copy(); // Can't slice this one due to EntityMap :(
+        /* Modification due to a misunderstanding of the primary (md_5) or secondary (yesdog) author... not sure.
+        But lets make sure we have 16 bytes of *head* room for rewriting, plus 16 tail. */
+        ByteBuf slice = ctx.alloc().ioBuffer(in.readableBytes() + 32);
+        slice.writerIndex(slice.writerIndex() + 16);
+        slice.readerIndex(slice.writerIndex());
+        try {
+            slice.writeBytes(in.markReaderIndex());
+        } finally {
+            in.resetReaderIndex();
+        }
+        //Waterdog end
 
         Object packetTypeInfo = null;
         try
diff --git a/protocol/src/main/java/net/md_5/bungee/protocol/MinecraftEncoder.java b/protocol/src/main/java/net/md_5/bungee/protocol/MinecraftEncoder.java
index 9aac7ca9..57e0088f 100644
--- a/protocol/src/main/java/net/md_5/bungee/protocol/MinecraftEncoder.java
+++ b/protocol/src/main/java/net/md_5/bungee/protocol/MinecraftEncoder.java
@@ -23,4 +23,14 @@ public class MinecraftEncoder extends MessageToByteEncoder<DefinedPacket>
         DefinedPacket.writeVarInt( prot.getId( msg.getClass(), protocolVersion ), out );
         msg.write0( out, prot.getDirection(), protocolVersion );
     }
+
+    // Waterdog start
+    @Override
+    public boolean acceptOutboundMessage(Object msg) throws Exception {
+        Protocol.DirectionData prot = ( server ) ? protocol.TO_CLIENT : protocol.TO_SERVER;
+        if (ProtocolConstants.isPE(protocolVersion) && msg instanceof DefinedPacket &&
+                !prot.hasPacket(((DefinedPacket) msg).getClass(), protocolVersion)) return false;
+        return super.acceptOutboundMessage(msg);
+    }
+    // Waterdog end
 }
diff --git a/protocol/src/main/java/net/md_5/bungee/protocol/Protocol.java b/protocol/src/main/java/net/md_5/bungee/protocol/Protocol.java
index f460a346..b5524ef0 100644
--- a/protocol/src/main/java/net/md_5/bungee/protocol/Protocol.java
+++ b/protocol/src/main/java/net/md_5/bungee/protocol/Protocol.java
@@ -41,6 +41,16 @@ import net.md_5.bungee.protocol.packet.TabCompleteRequest;
 import net.md_5.bungee.protocol.packet.TabCompleteResponse;
 import net.md_5.bungee.protocol.packet.Team;
 import net.md_5.bungee.protocol.packet.Title;
+import network.ycc.waterdog.pe.packet.PEEncryptionResponse;
+import network.ycc.waterdog.pe.packet.PECommand;
+import network.ycc.waterdog.pe.packet.PEHandshake;
+import network.ycc.waterdog.pe.packet.PELocalPlayerInitialized;
+import network.ycc.waterdog.pe.packet.PELogin;
+import network.ycc.waterdog.pe.packet.PEResourcePack;
+import network.ycc.waterdog.pe.packet.PEResourcePackResponse;
+import network.ycc.waterdog.pe.packet.PEResourceStack;
+import network.ycc.waterdog.pe.packet.PEEncryptionRequest;
+import network.ycc.waterdog.pe.packet.PETransfer;
 
 public enum Protocol
 {
@@ -50,6 +60,16 @@ public enum Protocol
     {
 
         {
+            // Waterdog start
+            TO_SERVER.registerPacket(
+                    PEHandshake.class,
+                    map( ProtocolConstants.MINECRAFT_PE_1_8, 0x01 )
+            );
+            TO_CLIENT.registerPacket(
+                    KeepAlive.class,
+                    map( ProtocolConstants.MINECRAFT_PE_1_8, 0x00 )
+            );
+            // Waterdog end
             TO_SERVER.registerPacket(
                     Handshake.class,
                     map( ProtocolConstants.MINECRAFT_1_7_2, 0x00 ) // Travertine
@@ -61,8 +81,39 @@ public enum Protocol
     {
 
         {
+            // Waterdog start
+            TO_CLIENT.registerPacket(
+                    PEResourcePack.class,
+                    map( ProtocolConstants.MINECRAFT_PE_1_8, 0x06 )
+            );
+            TO_CLIENT.registerPacket(
+                    PEResourceStack.class,
+                    map( ProtocolConstants.MINECRAFT_PE_1_8, 0x07 )
+            );
+            TO_CLIENT.registerPacket(
+                    PELogin.class,
+                    map( ProtocolConstants.MINECRAFT_PE_1_8, 0x0B )
+            );
+            TO_CLIENT.registerPacket(
+                    PETransfer.class,
+                    map( ProtocolConstants.MINECRAFT_PE_1_8, 0x55 )
+            );
+            TO_SERVER.registerPacket(
+                    PECommand.class,
+                    map( ProtocolConstants.MINECRAFT_PE_1_8, 0x4D )
+            );
+            TO_SERVER.registerPacket(
+                    PEResourcePackResponse.class,
+                    map( ProtocolConstants.MINECRAFT_PE_1_8, 0x08 )
+            );
+            TO_SERVER.registerPacket(
+                    PELocalPlayerInitialized.class,
+                    map( ProtocolConstants.MINECRAFT_PE_1_8, 0x71 )
+            );
+            // Waterdog end
             TO_CLIENT.registerPacket(
                     KeepAlive.class,
+                    map( ProtocolConstants.MINECRAFT_PE_1_8, 0x00 ), // Waterdog
                     map( ProtocolConstants.MINECRAFT_1_7_2, 0x00 ), // Travertine
                     map( ProtocolConstants.MINECRAFT_1_9, 0x1F ),
                     map( ProtocolConstants.MINECRAFT_1_13, 0x21 )
@@ -75,12 +126,14 @@ public enum Protocol
             );
             TO_CLIENT.registerPacket(
                     Chat.class,
+                    map( ProtocolConstants.MINECRAFT_PE_1_8, 0x09 ), // Waterdog
                     map( ProtocolConstants.MINECRAFT_1_7_2, 0x02 ), // Travertine
                     map( ProtocolConstants.MINECRAFT_1_9, 0x0F ),
                     map( ProtocolConstants.MINECRAFT_1_13, 0x0E )
             );
             TO_CLIENT.registerPacket(
                     Respawn.class,
+                    map( ProtocolConstants.MINECRAFT_PE_1_8, 0x3D ), // Waterdog
                     map( ProtocolConstants.MINECRAFT_1_7_2, 0x07 ), // Travertine
                     map( ProtocolConstants.MINECRAFT_1_9, 0x33 ),
                     map( ProtocolConstants.MINECRAFT_1_12, 0x34 ),
@@ -157,12 +210,14 @@ public enum Protocol
             );
             TO_CLIENT.registerPacket(
                     PluginMessage.class,
+                    map( ProtocolConstants.MINECRAFT_PE_1_8, 0x75 ), // Waterdog
                     map( ProtocolConstants.MINECRAFT_1_7_2, 0x3F ), // Travertine
                     map( ProtocolConstants.MINECRAFT_1_9, 0x18 ),
                     map( ProtocolConstants.MINECRAFT_1_13, 0x19 )
             );
             TO_CLIENT.registerPacket(
                     Kick.class,
+                    map( ProtocolConstants.MINECRAFT_PE_1_8, 0x05 ), // Waterdog
                     map( ProtocolConstants.MINECRAFT_1_7_2, 0x40 ), // Travertine
                     map( ProtocolConstants.MINECRAFT_1_9, 0x1A ),
                     map( ProtocolConstants.MINECRAFT_1_13, 0x1B )
@@ -196,6 +251,7 @@ public enum Protocol
 
             TO_SERVER.registerPacket(
                     KeepAlive.class,
+                    map( ProtocolConstants.MINECRAFT_PE_1_8, 0x00 ), // Waterdog
                     map( ProtocolConstants.MINECRAFT_1_7_2, 0x00 ), // Travertine
                     map( ProtocolConstants.MINECRAFT_1_9, 0x0B ),
                     map( ProtocolConstants.MINECRAFT_1_12, 0x0C ),
@@ -204,6 +260,7 @@ public enum Protocol
             );
             TO_SERVER.registerPacket(
                     Chat.class,
+                    map( ProtocolConstants.MINECRAFT_PE_1_8, 0x09 ), // Waterdog
                     map( ProtocolConstants.MINECRAFT_1_7_2, 0x01 ), // Travertine
                     map( ProtocolConstants.MINECRAFT_1_9, 0x02 ),
                     map( ProtocolConstants.MINECRAFT_1_12, 0x03 ),
@@ -219,6 +276,7 @@ public enum Protocol
             );
             TO_SERVER.registerPacket(
                     ClientSettings.class,
+                    map( ProtocolConstants.MINECRAFT_PE_1_8, 0x45 ), // Waterdog
                     map( ProtocolConstants.MINECRAFT_1_7_2, 0x15 ), // Travertine
                     map( ProtocolConstants.MINECRAFT_1_9, 0x04 ),
                     map( ProtocolConstants.MINECRAFT_1_12, 0x05 ),
@@ -226,6 +284,7 @@ public enum Protocol
             );
             TO_SERVER.registerPacket(
                     PluginMessage.class,
+                    map( ProtocolConstants.MINECRAFT_PE_1_8, 0x75 ), // Waterdog
                     map( ProtocolConstants.MINECRAFT_1_7_2, 0x17 ), // Travertine
                     map( ProtocolConstants.MINECRAFT_1_9, 0x09 ),
                     map( ProtocolConstants.MINECRAFT_1_12, 0x0A ),
@@ -263,8 +322,19 @@ public enum Protocol
     {
 
         {
+            // Waterdog start
+            TO_CLIENT.registerPacket(
+                    PEEncryptionRequest.class,
+                    map( ProtocolConstants.MINECRAFT_PE_1_8, 0x03 )
+            );
+            TO_SERVER.registerPacket(
+                    PEEncryptionResponse.class,
+                    map( ProtocolConstants.MINECRAFT_PE_1_8, 0x04 )
+            );
+            // Waterdog end
             TO_CLIENT.registerPacket(
                     Kick.class,
+                    map( ProtocolConstants.MINECRAFT_PE_1_8, 0x05 ), // Waterdog
                     map( ProtocolConstants.MINECRAFT_1_7_2, 0x00 ) // Travertine
             );
             TO_CLIENT.registerPacket(
@@ -273,6 +343,7 @@ public enum Protocol
             );
             TO_CLIENT.registerPacket(
                     LoginSuccess.class,
+                    map( ProtocolConstants.MINECRAFT_PE_1_8, 0x02 ), // Waterdog
                     map( ProtocolConstants.MINECRAFT_1_7_2, 0x02 ) // Travertine
             );
             TO_CLIENT.registerPacket(
@@ -395,6 +466,13 @@ public enum Protocol
             return supportsForge || i >= 0 && i <= MAX_PACKET_ID;
         }
 
+        // Waterdog start
+        public boolean hasPacket(Class<? extends DefinedPacket> packet, int version) {
+            ProtocolData protocol = protocols.get( version );
+            return protocol.packetMap.containsKey(packet);
+        }
+        // Waterdog end
+
         public final DefinedPacket createPacket(int id, int version)
         {
             return createPacket(id, version, true);
@@ -409,7 +487,7 @@ public enum Protocol
             }
             if ( !hasPacket(id, supportsForge) )
             {
-                if ( ProtocolConstants.isBeforeOrEq( version, ProtocolConstants.MINECRAFT_1_7_6 ) ) {
+                if ( ProtocolConstants.isBeforeOrEq( version, ProtocolConstants.MINECRAFT_1_7_6 ) || ProtocolConstants.isPE(version) ) { // Waterdog, Travertine
                     return null;
                 } else {
                     throw new BadPacketException( "Packet with id " + id + " outside of range " );
@@ -442,6 +520,13 @@ public enum Protocol
                         continue;
                     }
 
+                    // Waterdog start - dont carry pe mappings into pc
+                    while (protocol > 0 && mapping.protocolVersion < 0) {
+                        if (mappingIndex + 1 < mappings.length) mapping = mappings[++mappingIndex];
+                        else return;
+                    }
+                    // Waterdog end
+
                     if ( mapping.protocolVersion < protocol && mappingIndex + 1 < mappings.length )
                     {
                         // Mapping is non current, but the next one may be ok
diff --git a/protocol/src/main/java/net/md_5/bungee/protocol/ProtocolConstants.java b/protocol/src/main/java/net/md_5/bungee/protocol/ProtocolConstants.java
index 67f2976e..2b46ca32 100644
--- a/protocol/src/main/java/net/md_5/bungee/protocol/ProtocolConstants.java
+++ b/protocol/src/main/java/net/md_5/bungee/protocol/ProtocolConstants.java
@@ -6,8 +6,16 @@ import java.util.List;
 public class ProtocolConstants
 {
 
-    public static final int MINECRAFT_1_7_2 = 4;
-    public static final int MINECRAFT_1_7_6 = 5;
+    // Waterdog start
+    public static final int PE_PROTOCOL_OFFSET = 1000;
+    public static final int MINECRAFT_PE_1_8 = 313 - PE_PROTOCOL_OFFSET;
+    public static final int MINECRAFT_PE_1_9 = 332 - PE_PROTOCOL_OFFSET;
+    public static final int MINECRAFT_PE_1_10 = 340 - PE_PROTOCOL_OFFSET;
+    public static final int MINECRAFT_PE_1_11 = 354 - PE_PROTOCOL_OFFSET;
+    // Waterdog end
+
+    public static final int MINECRAFT_1_7_2 = 4; // Travertine
+    public static final int MINECRAFT_1_7_6 = 5; // Travertine
     public static final int MINECRAFT_1_8 = 47;
     public static final int MINECRAFT_1_9 = 107;
     public static final int MINECRAFT_1_9_1 = 108;
@@ -23,7 +31,13 @@ public class ProtocolConstants
     public static final int MINECRAFT_1_13_1 = 401;
     public static final int MINECRAFT_1_13_2 = 404;
     public static final List<String> SUPPORTED_VERSIONS = Arrays.asList(
-            "1.7.x",
+            // Waterdog start
+            "PE-1.8.x",
+            "PE-1.9.x",
+            "PE-1.10.x",
+            "PE-1.11.x",
+            // Waterdog end
+            "1.7.x", // Travertine
             "1.8.x",
             "1.9.x",
             "1.10.x",
@@ -32,8 +46,14 @@ public class ProtocolConstants
             "1.13.x"
     );
     public static final List<Integer> SUPPORTED_VERSION_IDS = Arrays.asList(
-            ProtocolConstants.MINECRAFT_1_7_2,
-            ProtocolConstants.MINECRAFT_1_7_6,
+            // Waterdog start
+            ProtocolConstants.MINECRAFT_PE_1_8,
+            ProtocolConstants.MINECRAFT_PE_1_9,
+            ProtocolConstants.MINECRAFT_PE_1_10,
+            ProtocolConstants.MINECRAFT_PE_1_11,
+            // Waterdog end
+            ProtocolConstants.MINECRAFT_1_7_2, // Travertine
+            ProtocolConstants.MINECRAFT_1_7_6, // Travertine
             ProtocolConstants.MINECRAFT_1_8,
             ProtocolConstants.MINECRAFT_1_9,
             ProtocolConstants.MINECRAFT_1_9_1,
@@ -52,14 +72,22 @@ public class ProtocolConstants
 
     public static final boolean isBeforeOrEq(int before, int other)
     {
+            if (!(isPE(before) && isPE(other))) return false; // Waterdog - no compare PE
             return before <= other;
     }
 
     public static final boolean isAfterOrEq(int after, int other)
     {
+            if (!(isPE(after) && isPE(other))) return false; // Waterdog - no compare PE
             return after >= other;
     }
 
+    // Waterdog start
+    public static final boolean isPE(int v) {
+        return v < -1;
+    }
+    // Waterdog end
+
     public enum Direction
     {
 
diff --git a/protocol/src/main/java/net/md_5/bungee/protocol/packet/Chat.java b/protocol/src/main/java/net/md_5/bungee/protocol/packet/Chat.java
index 7b988611..0ea00827 100644
--- a/protocol/src/main/java/net/md_5/bungee/protocol/packet/Chat.java
+++ b/protocol/src/main/java/net/md_5/bungee/protocol/packet/Chat.java
@@ -1,6 +1,8 @@
 package net.md_5.bungee.protocol.packet;
 
 import io.github.waterfallmc.travertine.protocol.MultiVersionPacketV17;
+import net.md_5.bungee.api.chat.TextComponent;
+import net.md_5.bungee.chat.ComponentSerializer;
 import io.netty.buffer.ByteBuf;
 import lombok.AllArgsConstructor;
 import lombok.Data;
@@ -8,6 +10,7 @@ import lombok.EqualsAndHashCode;
 import lombok.NoArgsConstructor;
 import net.md_5.bungee.protocol.AbstractPacketHandler;
 import net.md_5.bungee.protocol.ProtocolConstants;
+import network.ycc.waterdog.pe.PEDataValues;
 
 @Data
 @NoArgsConstructor
@@ -15,7 +18,6 @@ import net.md_5.bungee.protocol.ProtocolConstants;
 @EqualsAndHashCode(callSuper = false)
 public class Chat extends MultiVersionPacketV17
 {
-
     private String message;
     private byte position;
 
@@ -35,6 +37,20 @@ public class Chat extends MultiVersionPacketV17
     @Override
     public void read(ByteBuf buf, ProtocolConstants.Direction direction, int protocolVersion)
     {
+        // Waterdog start
+        if (ProtocolConstants.isPE(protocolVersion)) {
+            position = (byte) PEDataValues.getPcChatType(buf.readUnsignedByte());
+            buf.readBoolean(); //needs translation
+            if (direction == ProtocolConstants.Direction.TO_SERVER) {
+                readString(buf); //sender
+                message = readString(buf);
+            } else {
+                message = ComponentSerializer.toString(TextComponent.fromLegacyText(readString(buf)));
+            }
+            buf.skipBytes(buf.readableBytes());
+            return;
+        }
+        // Waterdog end
         // Waterfall start
         if (direction == ProtocolConstants.Direction.TO_CLIENT) {
             this.message = readString(buf, Short.MAX_VALUE * 8 + 8);
@@ -58,6 +74,21 @@ public class Chat extends MultiVersionPacketV17
     @Override
     public void write(ByteBuf buf, ProtocolConstants.Direction direction, int protocolVersion)
     {
+        // Waterdog start
+        if (ProtocolConstants.isPE(protocolVersion)) {
+            buf.writeByte(PEDataValues.getPeChatType(position, direction));
+            buf.writeBoolean(false);
+            if (direction == ProtocolConstants.Direction.TO_SERVER) {
+                writeString("", buf); //sender
+                writeString(message, buf);
+            } else {
+                writeString(ComponentSerializer.parse(message)[0].toLegacyText(), buf);
+            }
+            writeString("", buf);
+            writeString("", buf);
+            return;
+        }
+        // Waterdog end
         // Waterfall start
         if (direction == ProtocolConstants.Direction.TO_CLIENT) {
             writeString(this.message, Short.MAX_VALUE * 8 + 8, buf);
diff --git a/protocol/src/main/java/net/md_5/bungee/protocol/packet/ClientSettings.java b/protocol/src/main/java/net/md_5/bungee/protocol/packet/ClientSettings.java
index 431b2eb8..881698cc 100644
--- a/protocol/src/main/java/net/md_5/bungee/protocol/packet/ClientSettings.java
+++ b/protocol/src/main/java/net/md_5/bungee/protocol/packet/ClientSettings.java
@@ -41,6 +41,13 @@ public class ClientSettings extends MultiVersionPacketV17
     @Override
     public void read(ByteBuf buf, ProtocolConstants.Direction direction, int protocolVersion)
     {
+        // Waterdog start
+        if (ProtocolConstants.isPE(protocolVersion)) {
+            viewDistance = (byte) readSVarInt(buf);
+            locale = "";
+            return;
+        }
+        // Waterdog end
         locale = readString( buf );
         viewDistance = buf.readByte();
         chatFlags = protocolVersion >= ProtocolConstants.MINECRAFT_1_9 ? DefinedPacket.readVarInt( buf ) : buf.readUnsignedByte();
@@ -55,6 +62,12 @@ public class ClientSettings extends MultiVersionPacketV17
     @Override
     public void write(ByteBuf buf, ProtocolConstants.Direction direction, int protocolVersion)
     {
+        // Waterdog start
+        if (ProtocolConstants.isPE(protocolVersion)) {
+            writeSVarInt(buf, viewDistance);
+            return;
+        }
+        // Waterdog end
         writeString( locale, buf );
         buf.writeByte( viewDistance );
         if ( protocolVersion >= ProtocolConstants.MINECRAFT_1_9 )
diff --git a/protocol/src/main/java/net/md_5/bungee/protocol/packet/KeepAlive.java b/protocol/src/main/java/net/md_5/bungee/protocol/packet/KeepAlive.java
index 56e6e522..7ca8306e 100644
--- a/protocol/src/main/java/net/md_5/bungee/protocol/packet/KeepAlive.java
+++ b/protocol/src/main/java/net/md_5/bungee/protocol/packet/KeepAlive.java
@@ -29,6 +29,12 @@ public class KeepAlive extends MultiVersionPacketV17
     @Override
     public void read(ByteBuf buf, ProtocolConstants.Direction direction, int protocolVersion)
     {
+        // Waterdog start - empty keepalive
+        if (ProtocolConstants.isPE(protocolVersion)) {
+            buf.skipBytes(buf.readableBytes());
+            return;
+        }
+        // Waterdog end
         randomId = ( protocolVersion >= ProtocolConstants.MINECRAFT_1_12_2 ) ? buf.readLong() : readVarInt( buf );
     }
 
@@ -43,6 +49,7 @@ public class KeepAlive extends MultiVersionPacketV17
     @Override
     public void write(ByteBuf buf, ProtocolConstants.Direction direction, int protocolVersion)
     {
+        if (ProtocolConstants.isPE(protocolVersion)) return; // Waterdog - empty keepalive
         if ( protocolVersion >= ProtocolConstants.MINECRAFT_1_12_2 )
         {
             buf.writeLong( randomId );
diff --git a/protocol/src/main/java/net/md_5/bungee/protocol/packet/Kick.java b/protocol/src/main/java/net/md_5/bungee/protocol/packet/Kick.java
index 05ae1ae0..a88e8b87 100644
--- a/protocol/src/main/java/net/md_5/bungee/protocol/packet/Kick.java
+++ b/protocol/src/main/java/net/md_5/bungee/protocol/packet/Kick.java
@@ -1,5 +1,8 @@
 package net.md_5.bungee.protocol.packet;
 
+import io.netty.buffer.ByteBufUtil;
+import net.md_5.bungee.api.chat.TextComponent;
+import net.md_5.bungee.chat.ComponentSerializer;
 import net.md_5.bungee.protocol.DefinedPacket;
 import io.netty.buffer.ByteBuf;
 import lombok.AllArgsConstructor;
@@ -7,6 +10,7 @@ import lombok.Data;
 import lombok.EqualsAndHashCode;
 import lombok.NoArgsConstructor;
 import net.md_5.bungee.protocol.AbstractPacketHandler;
+import net.md_5.bungee.protocol.ProtocolConstants;
 
 @Data
 @NoArgsConstructor
@@ -18,14 +22,28 @@ public class Kick extends DefinedPacket
     private String message;
 
     @Override
-    public void read(ByteBuf buf)
+    public void read(ByteBuf buf, ProtocolConstants.Direction direction, int protocolVersion) // Waterdog
     {
+        // Waterdog start
+        if (ProtocolConstants.isPE(protocolVersion)) {
+            buf.readBoolean(); //hide disconnect screen
+            message = ComponentSerializer.toString(new TextComponent(readString(buf)));
+            return;
+        }
+        // Waterdog end
         message = readString( buf );
     }
 
     @Override
-    public void write(ByteBuf buf)
+    public void write(ByteBuf buf, ProtocolConstants.Direction direction, int protocolVersion) // Waterdog
     {
+        // Waterdog start
+        if (ProtocolConstants.isPE(protocolVersion)) {
+            buf.writeBoolean( false ); //hide disconnect screen
+            writeString( ComponentSerializer.parse(message)[0].toLegacyText(), buf );
+            return;
+        }
+        // Waterdog end
         writeString( message, buf );
     }
 
diff --git a/protocol/src/main/java/net/md_5/bungee/protocol/packet/LoginSuccess.java b/protocol/src/main/java/net/md_5/bungee/protocol/packet/LoginSuccess.java
index 09c718b5..bf1f1e0b 100644
--- a/protocol/src/main/java/net/md_5/bungee/protocol/packet/LoginSuccess.java
+++ b/protocol/src/main/java/net/md_5/bungee/protocol/packet/LoginSuccess.java
@@ -7,6 +7,7 @@ import lombok.EqualsAndHashCode;
 import lombok.NoArgsConstructor;
 import net.md_5.bungee.protocol.DefinedPacket;
 import net.md_5.bungee.protocol.AbstractPacketHandler;
+import net.md_5.bungee.protocol.ProtocolConstants;
 
 @Data
 @NoArgsConstructor
@@ -14,22 +15,38 @@ import net.md_5.bungee.protocol.AbstractPacketHandler;
 @EqualsAndHashCode(callSuper = false)
 public class LoginSuccess extends DefinedPacket
 {
+    // Waterdog start
+    public static final int PE_LOGIN_SUCCESS = 0;
+    public static final int PE_PLAYER_SPAWN = 3;
+    // Waterdog end
 
     private String uuid;
     private String username;
 
     @Override
-    public void read(ByteBuf buf)
+    public void read(ByteBuf buf, ProtocolConstants.Direction direction, int protocolVersion) // Waterdog
     {
-        uuid = readString( buf );
-        username = readString( buf );
+        // Waterdog start
+        if (ProtocolConstants.isPE(protocolVersion)) {
+            buf.readInt();
+            return;
+        }
+        // Waterdog end
+        uuid = readString(buf);
+        username = readString(buf);
     }
 
     @Override
-    public void write(ByteBuf buf)
+    public void write(ByteBuf buf, ProtocolConstants.Direction direction, int protocolVersion) // Waterdog
     {
-        writeString( uuid, buf );
-        writeString( username, buf );
+        // Waterdog start
+        if (ProtocolConstants.isPE(protocolVersion)) {
+            buf.writeInt(PE_LOGIN_SUCCESS);
+            return;
+        }
+        // Waterdog end
+        writeString(uuid, buf);
+        writeString(username, buf);
     }
 
     @Override
diff --git a/protocol/src/main/java/net/md_5/bungee/protocol/packet/PluginMessage.java b/protocol/src/main/java/net/md_5/bungee/protocol/packet/PluginMessage.java
index ac7451dc..900124a3 100644
--- a/protocol/src/main/java/net/md_5/bungee/protocol/packet/PluginMessage.java
+++ b/protocol/src/main/java/net/md_5/bungee/protocol/packet/PluginMessage.java
@@ -91,7 +91,7 @@ public class PluginMessage extends MultiVersionPacketV17
     @Override
     public void read(ByteBuf buf, ProtocolConstants.Direction direction, int protocolVersion)
     {
-        tag = ( protocolVersion >= ProtocolConstants.MINECRAFT_1_13 ) ? MODERNISE.apply( readString( buf ) ) : readString( buf );
+        tag = ( protocolVersion >= ProtocolConstants.MINECRAFT_1_13 || ProtocolConstants.isPE(protocolVersion) ) ? MODERNISE.apply( readString( buf ) ) : readString( buf ); // Waterdog
         int maxSize = direction == ProtocolConstants.Direction.TO_SERVER ? Short.MAX_VALUE : 0x100000;
         Preconditions.checkArgument( buf.readableBytes() < maxSize );
         data = new byte[ buf.readableBytes() ];
@@ -110,7 +110,7 @@ public class PluginMessage extends MultiVersionPacketV17
     @Override
     public void write(ByteBuf buf, ProtocolConstants.Direction direction, int protocolVersion)
     {
-        writeString( ( protocolVersion >= ProtocolConstants.MINECRAFT_1_13 ) ? MODERNISE.apply( tag ) : tag, buf );
+        writeString( ( protocolVersion >= ProtocolConstants.MINECRAFT_1_13 || ProtocolConstants.isPE(protocolVersion) ) ? MODERNISE.apply( tag ) : tag, buf ); // Waterdog
         buf.writeBytes( data );
     }
 
diff --git a/protocol/src/main/java/net/md_5/bungee/protocol/packet/Respawn.java b/protocol/src/main/java/net/md_5/bungee/protocol/packet/Respawn.java
index d0a7529e..e6552fe7 100644
--- a/protocol/src/main/java/net/md_5/bungee/protocol/packet/Respawn.java
+++ b/protocol/src/main/java/net/md_5/bungee/protocol/packet/Respawn.java
@@ -7,6 +7,8 @@ import lombok.Data;
 import lombok.EqualsAndHashCode;
 import lombok.NoArgsConstructor;
 import net.md_5.bungee.protocol.AbstractPacketHandler;
+import net.md_5.bungee.protocol.ProtocolConstants;
+import network.ycc.waterdog.pe.PEDataValues;
 
 @Data
 @NoArgsConstructor
@@ -21,8 +23,18 @@ public class Respawn extends DefinedPacket
     private String levelType;
 
     @Override
-    public void read(ByteBuf buf)
+    public void read(ByteBuf buf, ProtocolConstants.Direction direction, int protocolVersion) // Waterdog
     {
+        // Waterdog start
+        if (ProtocolConstants.isPE(protocolVersion)) {
+            dimension = PEDataValues.getPcDimensionId(readSVarInt(buf));
+            buf.readFloatLE(); //x
+            buf.readFloatLE(); //y
+            buf.readFloatLE(); //z
+            buf.readBoolean(); //respawn
+            return;
+        }
+        // Waterdog end
         dimension = buf.readInt();
         difficulty = buf.readUnsignedByte();
         gameMode = buf.readUnsignedByte();
@@ -30,8 +42,18 @@ public class Respawn extends DefinedPacket
     }
 
     @Override
-    public void write(ByteBuf buf)
+    public void write(ByteBuf buf, ProtocolConstants.Direction direction, int protocolVersion) // Waterdog
     {
+        // Waterdog start
+        if (ProtocolConstants.isPE(protocolVersion)) {
+            writeSVarInt(buf, PEDataValues.getPeDimensionId(dimension));
+            buf.writeFloatLE(0); //x
+            buf.writeFloatLE(0); //y
+            buf.writeFloatLE(0); //z
+            buf.writeBoolean(true); //respawn
+            return;
+        }
+        // Waterdog end
         buf.writeInt( dimension );
         buf.writeByte( difficulty );
         buf.writeByte( gameMode );
diff --git a/protocol/src/main/java/network/ycc/waterdog/pe/PEDataValues.java b/protocol/src/main/java/network/ycc/waterdog/pe/PEDataValues.java
new file mode 100644
index 00000000..fa848edc
--- /dev/null
+++ b/protocol/src/main/java/network/ycc/waterdog/pe/PEDataValues.java
@@ -0,0 +1,47 @@
+package network.ycc.waterdog.pe;
+
+import net.md_5.bungee.api.ChatMessageType;
+import net.md_5.bungee.protocol.ProtocolConstants;
+
+public class PEDataValues {
+    public static final int CHAT_CLIENT_RAW_TYPE = 0;
+    public static final int CHAT_CLIENT_CHAT_TYPE = 1;
+    public static final int CHAT_CLIENT_TIP_TYPE = 5;
+    public static final int CHAT_CLIENT_SYSTEM_TYPE = 6;
+
+    public static int getPcChatType(int peId) {
+        switch (peId) {
+            case CHAT_CLIENT_TIP_TYPE: return ChatMessageType.ACTION_BAR.ordinal();
+            case CHAT_CLIENT_SYSTEM_TYPE: return ChatMessageType.SYSTEM.ordinal();
+            default: return ChatMessageType.CHAT.ordinal();
+        }
+    }
+
+    public static int getPeChatType(int pcId, ProtocolConstants.Direction direction) {
+        switch (ChatMessageType.values()[pcId]) {
+            case ACTION_BAR: return CHAT_CLIENT_TIP_TYPE;
+            case SYSTEM: return CHAT_CLIENT_SYSTEM_TYPE;
+            default:
+                return direction == ProtocolConstants.Direction.TO_SERVER ?
+                        CHAT_CLIENT_CHAT_TYPE : CHAT_CLIENT_RAW_TYPE;
+        }
+    }
+
+    public static int getPeDimensionId(int dimId) {
+        switch (dimId) {
+            case -1: return 1;
+            case 1: return 2;
+            case 0: return 0;
+            default: throw new IllegalArgumentException("Unknown dim id " + dimId);
+        }
+    }
+
+    public static int getPcDimensionId(int dimId) {
+        switch (dimId) {
+            case 1: return -1;
+            case 2: return 1;
+            case 0: return 0;
+            default: throw new IllegalArgumentException("Unknown dim id " + dimId);
+        }
+    }
+}
diff --git a/protocol/src/main/java/network/ycc/waterdog/pe/packet/PECommand.java b/protocol/src/main/java/network/ycc/waterdog/pe/packet/PECommand.java
new file mode 100644
index 00000000..94786b16
--- /dev/null
+++ b/protocol/src/main/java/network/ycc/waterdog/pe/packet/PECommand.java
@@ -0,0 +1,37 @@
+package network.ycc.waterdog.pe.packet;
+
+import io.netty.buffer.ByteBuf;
+
+import lombok.Data;
+import lombok.EqualsAndHashCode;
+import lombok.NoArgsConstructor;
+
+import net.md_5.bungee.protocol.AbstractPacketHandler;
+import net.md_5.bungee.protocol.DefinedPacket;
+import net.md_5.bungee.protocol.ProtocolConstants;
+
+@Data
+@NoArgsConstructor
+@EqualsAndHashCode(callSuper = false)
+public class PECommand extends DefinedPacket {
+    String message;
+    private byte[] data;
+
+    @Override
+    public void read(ByteBuf buf, ProtocolConstants.Direction direction, int protocolVersion) {
+        setMessage(readString(buf));
+        data = new byte[buf.readableBytes()];
+        buf.readBytes(data);
+    }
+
+    @Override
+    public void write(ByteBuf buf, ProtocolConstants.Direction direction, int protocolVersion) {
+        writeString(getMessage(), buf);
+        buf.writeBytes(data);
+    }
+
+    @Override
+    public void handle(AbstractPacketHandler handler) throws Exception {
+        handler.handle(this);
+    }
+}
diff --git a/protocol/src/main/java/network/ycc/waterdog/pe/packet/PEEncryptionRequest.java b/protocol/src/main/java/network/ycc/waterdog/pe/packet/PEEncryptionRequest.java
new file mode 100644
index 00000000..75784080
--- /dev/null
+++ b/protocol/src/main/java/network/ycc/waterdog/pe/packet/PEEncryptionRequest.java
@@ -0,0 +1,31 @@
+package network.ycc.waterdog.pe.packet;
+
+import io.netty.buffer.ByteBuf;
+
+import lombok.AllArgsConstructor;
+import lombok.Data;
+import lombok.NoArgsConstructor;
+
+import net.md_5.bungee.protocol.AbstractPacketHandler;
+import net.md_5.bungee.protocol.DefinedPacket;
+
+@Data
+@AllArgsConstructor
+@NoArgsConstructor
+public class PEEncryptionRequest extends DefinedPacket {
+    private String jwtData;
+
+    @Override
+    public void read(ByteBuf buf) {
+        jwtData = readString(buf);
+    }
+
+    @Override
+    public void write(ByteBuf buf) {
+        writeString(jwtData, buf);
+    }
+
+    public void handle(AbstractPacketHandler handler) throws Exception {
+        handler.handle(this);
+    }
+}
diff --git a/protocol/src/main/java/network/ycc/waterdog/pe/packet/PEEncryptionResponse.java b/protocol/src/main/java/network/ycc/waterdog/pe/packet/PEEncryptionResponse.java
new file mode 100644
index 00000000..bfd8b92b
--- /dev/null
+++ b/protocol/src/main/java/network/ycc/waterdog/pe/packet/PEEncryptionResponse.java
@@ -0,0 +1,27 @@
+package network.ycc.waterdog.pe.packet;
+
+import io.netty.buffer.ByteBuf;
+
+import lombok.Data;
+import lombok.NoArgsConstructor;
+
+import net.md_5.bungee.protocol.AbstractPacketHandler;
+import net.md_5.bungee.protocol.DefinedPacket;
+
+@Data
+@NoArgsConstructor
+public class PEEncryptionResponse extends DefinedPacket {
+    @Override
+    public void write(ByteBuf buf) {
+
+    }
+
+    @Override
+    public void read(ByteBuf buf) {
+        buf.skipBytes(buf.readableBytes());
+    }
+
+    public void handle(AbstractPacketHandler handler) throws Exception {
+
+    }
+}
diff --git a/protocol/src/main/java/network/ycc/waterdog/pe/packet/PEHandshake.java b/protocol/src/main/java/network/ycc/waterdog/pe/packet/PEHandshake.java
new file mode 100644
index 00000000..6576d448
--- /dev/null
+++ b/protocol/src/main/java/network/ycc/waterdog/pe/packet/PEHandshake.java
@@ -0,0 +1,294 @@
+package network.ycc.waterdog.pe.packet;
+
+import com.google.common.base.Charsets;
+import com.google.common.base.Preconditions;
+import com.google.common.reflect.TypeToken;
+import com.google.gson.Gson;
+import com.google.gson.GsonBuilder;
+import com.google.gson.JsonElement;
+import com.google.gson.JsonPrimitive;
+import com.google.gson.JsonSyntaxException;
+import com.google.gson.JsonObject;
+
+import com.nimbusds.jose.JWSAlgorithm;
+import com.nimbusds.jose.JWSHeader;
+import com.nimbusds.jose.Payload;
+import com.nimbusds.jose.crypto.ECDSASigner;
+import com.nimbusds.jose.jwk.Curve;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufInputStream;
+import io.netty.handler.codec.DecoderException;
+import io.netty.handler.codec.EncoderException;
+
+import lombok.Data;
+import lombok.EqualsAndHashCode;
+import lombok.NoArgsConstructor;
+
+import net.md_5.bungee.protocol.ProtocolConstants;
+import net.md_5.bungee.protocol.packet.Handshake;
+
+import java.io.InputStreamReader;
+import java.math.BigInteger;
+import java.net.URI;
+import java.nio.charset.StandardCharsets;
+import java.security.Key;
+import java.security.KeyFactory;
+import java.security.KeyPair;
+import java.security.KeyPairGenerator;
+import java.security.NoSuchAlgorithmException;
+import java.security.PublicKey;
+import java.security.spec.InvalidKeySpecException;
+import java.security.spec.X509EncodedKeySpec;
+import java.text.ParseException;
+import java.util.Base64;
+import java.util.Collections;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.UUID;
+
+import com.nimbusds.jose.JOSEException;
+import com.nimbusds.jose.JWSObject;
+import com.nimbusds.jose.crypto.factories.DefaultJWSVerifierFactory;
+
+import org.apache.commons.lang3.tuple.ImmutablePair;
+import org.apache.commons.lang3.tuple.Pair;
+
+@Data
+@NoArgsConstructor
+@EqualsAndHashCode(callSuper = false)
+public class PEHandshake extends Handshake {
+    public static final String MOJANG_KEY = "MHYwEAYHKoZIzj0CAQYFK4EEACIDYgAE8ELkixyLcwlZryUQcu1TvPOmI2B7vX83ndnWRUaXm74wFfa5f/lwQNTfrLVHa2PmenpGI6JhIMUJaWZrjmMj90NoKNFSNBuKdm8rYiXsfaz3K36x/1U26HpG0ZxK/V1V";
+
+    static final Gson GSON = new GsonBuilder().setPrettyPrinting().create();
+
+    private String username;
+    private UUID uuid;
+    private boolean authorized;
+    private JsonObject clientInfo;
+
+    public PEHandshake(int protocolVersion, String host, int port, int requestedProtocol, String username, UUID uuid, boolean authorized, JsonObject clientInfo) {
+        super(protocolVersion, host, port, requestedProtocol);
+        this.username = username;
+        this.uuid = uuid;
+        this.authorized = authorized;
+        this.clientInfo = clientInfo;
+    }
+
+    @Override
+    public void read(ByteBuf buf) {
+        final int protocolVersion = buf.readInt() - ProtocolConstants.PE_PROTOCOL_OFFSET;
+        final ByteBuf loginData = buf.readSlice(readVarInt(buf));
+        final ByteBuf chainDataBytes = loginData.readSlice(loginData.readIntLE());
+        final ByteBuf jwsDataBytes = loginData.readSlice(loginData.readIntLE());
+        final Pair<Key, JsonObject> chainData = extractChainData(GSON.fromJson(
+                new InputStreamReader(new ByteBufInputStream(chainDataBytes)),
+                new TypeToken<Map<String, List<String>>>() {}.getType()
+        ));
+        final Key key = chainData.getLeft();
+        final JsonObject identityData = chainData.getRight();
+        final String jwsString = jwsDataBytes.readCharSequence(jwsDataBytes.readableBytes(), Charsets.UTF_8).toString();
+        final JWSObject additionalData;
+        try {
+            additionalData = JWSObject.parse(jwsString);
+        } catch (ParseException e) {
+            throw new DecoderException("Failed to parse jws string: " + jwsString, e);
+        }
+        clientInfo = GSON.fromJson(additionalData.getPayload().toString(), JsonObject.class);
+        final String serverAddr = clientInfo.get("ServerAddress").getAsString();
+        Preconditions.checkArgument(serverAddr != null, "ServerAddress is missing");
+        final String[] serverAddrSplit = serverAddr.split("[:]");
+
+        username = getString(identityData, "displayName");
+        uuid = UUID.fromString(getString(identityData, "identity")); //TODO: device UUID?
+        authorized = key != null;
+        if (authorized) {
+            uuid = new UUID(0, new BigInteger(getString(identityData, "XUID")).longValue());
+        }
+        setHost(serverAddrSplit[0]);
+        if (serverAddrSplit.length > 1) {
+            setPort(Integer.parseInt(serverAddrSplit[1]));
+        }
+        setProtocolVersion(protocolVersion);
+        setRequestedProtocol(2);
+    }
+
+    @Override
+    public void write(ByteBuf buf) {
+        final byte[] identityData = createIdentityData(username, uuid).getBytes(StandardCharsets.UTF_8);
+        final byte[] clientData = createClientData(clientInfo, getHost(), getPort(), uuid).getBytes(StandardCharsets.UTF_8);
+        buf.writeInt(getProtocolVersion() + ProtocolConstants.PE_PROTOCOL_OFFSET);
+        writeVarInt(buf, identityData.length + clientData.length + 8);
+        buf.writeIntLE(identityData.length);
+        buf.writeBytes(identityData);
+        buf.writeIntLE(clientData.length);
+        buf.writeBytes(clientData);
+    }
+
+    ////// READING
+
+    static Pair<Key, JsonObject> extractChainData(Map<String, List<String>> maindata) {
+        final List<String> chain = maindata.get("chain");
+        try {
+            PublicKey key = parseKey(MOJANG_KEY);
+            boolean foundMojangKey = false;
+            boolean signatureValid = false;
+            for (String element : chain) {
+                final JWSObject jwsobject = JWSObject.parse(element);
+                if (!foundMojangKey && jwsobject.getHeader().getX509CertURL().toString().equals(MOJANG_KEY)) {
+                    foundMojangKey = true;
+                    signatureValid = true;
+                }
+                if (foundMojangKey && !verify(jwsobject, key)) {
+                    signatureValid = false;
+                }
+                final JsonObject jsonobject = GSON.fromJson(jwsobject.getPayload().toString(), JsonObject.class);
+                key = parseKey(getString(jsonobject, "identityPublicKey"));
+                if (jsonobject.has("extraData")) {
+                    return new ImmutablePair<>(signatureValid ? key : null, getJsonObject(jsonobject, "extraData"));
+                }
+            }
+        } catch (InvalidKeySpecException | JOSEException e) {
+            throw new DecoderException("Unable to decode login chain", e);
+        } catch (ParseException e) {
+            throw new DecoderException("Unable to parse: " + maindata, e);
+        }
+        throw new DecoderException("Unable to find extraData");
+    }
+
+    static String getString(JsonObject jsonObject, String name) {
+        if (jsonObject.has(name)) {
+            return getAsString(jsonObject.get(name), name);
+        }
+        throw new JsonSyntaxException("Missing " + name + ", expected to find a string");
+    }
+
+    static String getAsString(JsonElement jsonElement, String name) {
+        if (jsonElement.isJsonPrimitive()) {
+            return jsonElement.getAsString();
+        }
+        throw new JsonSyntaxException("Expected " + name + " to be a string, was " + toString(jsonElement));
+    }
+
+    static JsonObject getAsJsonObject(JsonElement jsonElement, String name) {
+        if (jsonElement.isJsonObject()) {
+            return jsonElement.getAsJsonObject();
+        }
+        throw new JsonSyntaxException("Expected " + name + " to be a JsonObject, was " + toString(jsonElement));
+    }
+
+    static JsonObject getJsonObject(JsonObject jsonObject, String name) {
+        if (jsonObject.has(name)) {
+            return getAsJsonObject(jsonObject.get(name), name);
+        }
+        throw new JsonSyntaxException("Missing " + name + ", expected to find an Object");
+    }
+
+    static String toString(JsonElement jsonElement) {
+        final String abbreviateMiddle = String.valueOf(jsonElement);
+        if (jsonElement == null) {
+            return "null (missing)";
+        }
+        if (jsonElement.isJsonNull()) {
+            return "null (json)";
+        }
+        if (jsonElement.isJsonArray()) {
+            return "an array (" + abbreviateMiddle + ")";
+        }
+        if (jsonElement.isJsonObject()) {
+            return "an object (" + abbreviateMiddle + ")";
+        }
+        if (jsonElement.isJsonPrimitive()) {
+            final JsonPrimitive asJsonPrimitive = jsonElement.getAsJsonPrimitive();
+            if (asJsonPrimitive.isNumber()) {
+                return "a number (" + abbreviateMiddle + ")";
+            }
+            if (asJsonPrimitive.isBoolean()) {
+                return "a boolean (" + abbreviateMiddle + ")";
+            }
+        }
+        return abbreviateMiddle;
+    }
+
+    static final DefaultJWSVerifierFactory jwsverifierfactory = new DefaultJWSVerifierFactory();
+    static boolean verify(JWSObject object, PublicKey key) throws JOSEException {
+        return object.verify(jwsverifierfactory.createJWSVerifier(object.getHeader(), key));
+    }
+
+    static final KeyFactory keyfactory = getKeyFactory();
+    static KeyFactory getKeyFactory() {
+        try {
+            return KeyFactory.getInstance("EC");
+        } catch (NoSuchAlgorithmException e) {
+            throw new RuntimeException("Unable to init key factory", e);
+        }
+    }
+
+    static public PublicKey parseKey(String key) throws InvalidKeySpecException {
+        return keyfactory.generatePublic(new X509EncodedKeySpec(Base64.getDecoder().decode(key)));
+    }
+
+    ////// WRITING
+
+    static final KeyPair keyPair;
+    static {
+        try {
+            KeyPairGenerator gen = KeyPairGenerator.getInstance("EC");
+            gen.initialize(Curve.P_384.toECParameterSpec());
+            keyPair = gen.generateKeyPair();
+        } catch (Exception e) {
+            throw new RuntimeException("Unable to generate private keypair", e);
+        }
+    }
+
+    public static KeyPair getKeyPair() {
+        return keyPair;
+    }
+
+    @SuppressWarnings("serial")
+    static String createIdentityData(String username, UUID uuid) {
+        final Map<String, List<String>> chainmap = new HashMap<>();
+        final long nbf = System.currentTimeMillis() / 1000;
+        final long exp = nbf + 24 * 3600;
+        JsonObject dataChain = new JsonObject();
+        JsonObject extraData = new JsonObject();
+        extraData.addProperty("identity", uuid.toString());
+        extraData.addProperty("displayName", username);
+        //extraData.addProperty("XUID", "");
+        //chain
+        dataChain.addProperty("nbf", nbf - 1);
+        dataChain.addProperty("exp", exp);
+        dataChain.addProperty("iat", nbf);
+        dataChain.addProperty("iss", "self");
+        dataChain.addProperty("certificateAuthority", true);
+        dataChain.add("extraData", extraData);
+        dataChain.addProperty("randomNonce", UUID.randomUUID().getLeastSignificantBits());
+        dataChain.addProperty("identityPublicKey", Base64.getEncoder().encodeToString(keyPair.getPublic().getEncoded()));
+        chainmap.put("chain", Collections.singletonList(encodeJWT(dataChain)));
+        return GSON.toJson(chainmap, new TypeToken<Map<String, List<String>>>() {}.getType());
+    }
+
+    static String encodeJWT(JsonObject payload) {
+        try {
+            JWSObject jwsobject = new JWSObject(
+                    new JWSHeader.Builder(JWSAlgorithm.ES384)
+                            .x509CertURL(new URI(Base64.getEncoder().encodeToString(keyPair.getPublic().getEncoded())))
+                            .build(),
+                    new Payload(GSON.toJson(payload))
+            );
+            jwsobject.sign(new ECDSASigner(keyPair.getPrivate(), Curve.P_384));
+            return jwsobject.serialize();
+        } catch (Exception e) {
+            throw new EncoderException("Unable to encode jwt", e);
+        }
+    }
+
+    static String createClientData(JsonObject baseClientInfo, String host, int port, UUID uuid) {
+        JsonObject out = new JsonObject();
+        baseClientInfo.entrySet().forEach(entry -> out.add(entry.getKey(), entry.getValue()));
+        out.addProperty("ServerAddress", host + ":" + port);
+        out.addProperty("SelfSignedId", uuid.toString());
+        return encodeJWT(out);
+    }
+}
diff --git a/protocol/src/main/java/network/ycc/waterdog/pe/packet/PELocalPlayerInitialized.java b/protocol/src/main/java/network/ycc/waterdog/pe/packet/PELocalPlayerInitialized.java
new file mode 100644
index 00000000..711f1bb5
--- /dev/null
+++ b/protocol/src/main/java/network/ycc/waterdog/pe/packet/PELocalPlayerInitialized.java
@@ -0,0 +1,32 @@
+package network.ycc.waterdog.pe.packet;
+
+import io.netty.buffer.ByteBuf;
+
+import lombok.AllArgsConstructor;
+import lombok.Data;
+import lombok.NoArgsConstructor;
+
+import net.md_5.bungee.protocol.AbstractPacketHandler;
+import net.md_5.bungee.protocol.DefinedPacket;
+
+@Data
+@AllArgsConstructor
+@NoArgsConstructor
+public class PELocalPlayerInitialized extends DefinedPacket {
+    private long playerId;
+
+    @Override
+    public void read(ByteBuf buf) {
+        playerId = readVarLong(buf);
+    }
+
+    @Override
+    public void write(ByteBuf buf) {
+        writeVarLong(buf, playerId);
+    }
+
+    @Override
+    public void handle(AbstractPacketHandler handler) throws Exception {
+
+    }
+}
diff --git a/protocol/src/main/java/network/ycc/waterdog/pe/packet/PELogin.java b/protocol/src/main/java/network/ycc/waterdog/pe/packet/PELogin.java
new file mode 100644
index 00000000..56ba3e42
--- /dev/null
+++ b/protocol/src/main/java/network/ycc/waterdog/pe/packet/PELogin.java
@@ -0,0 +1,60 @@
+package network.ycc.waterdog.pe.packet;
+
+import io.netty.buffer.ByteBuf;
+
+import lombok.Data;
+import lombok.EqualsAndHashCode;
+import lombok.NoArgsConstructor;
+
+import net.md_5.bungee.protocol.ProtocolConstants;
+import net.md_5.bungee.protocol.packet.Login;
+import network.ycc.waterdog.pe.PEDataValues;
+
+@Data
+@NoArgsConstructor
+@EqualsAndHashCode(callSuper = false)
+public class PELogin extends Login {
+    private byte[] tailPayload;
+
+    public PELogin(int entityId, short gameMode, int dimension, short difficulty, short maxPlayers, String levelType, boolean reducedDebugInfo, byte[] tailPayload) {
+        super(entityId, gameMode, dimension, difficulty, maxPlayers, levelType, reducedDebugInfo);
+        this.tailPayload = tailPayload;
+    }
+
+    @Override
+    public void read(ByteBuf buf, ProtocolConstants.Direction direction, int protocolVersion) {
+        readSVarLong(buf); //entity id (but it's actually signed varlong, so we use the field below, which is unsigned)
+        setEntityId((int) readVarLong(buf));
+        setGameMode((short) readSVarInt(buf));
+        buf.readFloatLE(); //x
+        buf.readFloatLE(); //y
+        buf.readFloatLE(); //z
+        buf.readFloatLE(); //yaw
+        buf.readFloatLE(); //pitch
+        readSVarInt(buf); //seed
+        setDimension(PEDataValues.getPcDimensionId(readSVarInt(buf)));
+        readSVarInt(buf); //world type (1 - infinite)
+        readSVarInt(buf); // world gamemode (SURVIVAL)
+        setDifficulty((short) readSVarInt(buf));
+        tailPayload = new byte[buf.readableBytes()];
+        buf.readBytes(tailPayload);
+    }
+
+    @Override
+    public void write(ByteBuf buf, ProtocolConstants.Direction direction, int protocolVersion) {
+        writeSVarLong(buf, getEntityId());
+        writeVarLong(buf, getEntityId());
+        writeSVarInt(buf, getGameMode());
+        buf.writeFloatLE(0); //player x
+        buf.writeFloatLE(0); //player y
+        buf.writeFloatLE(0); //player z
+        buf.writeFloatLE(0); //player pitch
+        buf.writeFloatLE(0); //player yaw
+        writeSVarInt(buf, 0); //seed
+        writeSVarInt(buf, PEDataValues.getPeDimensionId(getDimension())); //world dimension
+        writeSVarInt(buf, 1); //world type (1 - infinite)
+        writeSVarInt(buf, 0); //world gamemode
+        writeSVarInt(buf, getDifficulty()); //world difficulty
+        buf.writeBytes(tailPayload);
+    }
+}
diff --git a/protocol/src/main/java/network/ycc/waterdog/pe/packet/PEResourcePack.java b/protocol/src/main/java/network/ycc/waterdog/pe/packet/PEResourcePack.java
new file mode 100644
index 00000000..55a572ef
--- /dev/null
+++ b/protocol/src/main/java/network/ycc/waterdog/pe/packet/PEResourcePack.java
@@ -0,0 +1,37 @@
+package network.ycc.waterdog.pe.packet;
+
+import io.netty.buffer.ByteBuf;
+
+import lombok.Data;
+import lombok.EqualsAndHashCode;
+
+import net.md_5.bungee.protocol.AbstractPacketHandler;
+import net.md_5.bungee.protocol.DefinedPacket;
+import net.md_5.bungee.protocol.ProtocolConstants;
+
+@Data
+@EqualsAndHashCode(callSuper = false)
+public class PEResourcePack extends DefinedPacket {
+    @Override
+    public void read(ByteBuf buf) {
+        buf.skipBytes(buf.readableBytes());
+    }
+
+    @Override
+    public void write(ByteBuf buf, ProtocolConstants.Direction direction, int protocolVersion) {
+        buf.writeBoolean(false); // required
+        buf.writeShortLE(0); //beh packs count
+        if (protocolVersion >= ProtocolConstants.MINECRAFT_PE_1_9) {
+            buf.writeBoolean(false); // ???
+        }
+        buf.writeShortLE(0); //res packs count
+        if (protocolVersion >= ProtocolConstants.MINECRAFT_PE_1_9) {
+            buf.writeBoolean(false); // ???
+        }
+    }
+
+    @Override
+    public void handle(AbstractPacketHandler handler) throws Exception {
+        handler.handle(this);
+    }
+}
diff --git a/protocol/src/main/java/network/ycc/waterdog/pe/packet/PEResourcePackResponse.java b/protocol/src/main/java/network/ycc/waterdog/pe/packet/PEResourcePackResponse.java
new file mode 100644
index 00000000..0948f2c4
--- /dev/null
+++ b/protocol/src/main/java/network/ycc/waterdog/pe/packet/PEResourcePackResponse.java
@@ -0,0 +1,40 @@
+package network.ycc.waterdog.pe.packet;
+
+import io.netty.buffer.ByteBuf;
+import lombok.AllArgsConstructor;
+import lombok.Data;
+import lombok.EqualsAndHashCode;
+
+import lombok.NoArgsConstructor;
+import net.md_5.bungee.protocol.AbstractPacketHandler;
+import net.md_5.bungee.protocol.DefinedPacket;
+
+@Data
+@NoArgsConstructor
+@AllArgsConstructor
+@EqualsAndHashCode(callSuper = false)
+public class PEResourcePackResponse extends DefinedPacket {
+    public static final byte STATUS_REFUSED = 1;
+    public static final byte STATUS_SEND_PACKS = 2;
+    public static final byte STATUS_HAVE_ALL_PACKS = 3;
+    public static final byte STATUS_COMPLETED = 4;
+
+    private int status;
+
+    @Override
+    public void read(ByteBuf buf) {
+        status = buf.readUnsignedByte();
+        buf.skipBytes(buf.readableBytes());
+    }
+
+    @Override
+    public void write(ByteBuf buf) {
+        buf.writeByte(status);
+        buf.writeShortLE(0); //n packs
+    }
+
+    @Override
+    public void handle(AbstractPacketHandler handler) throws Exception {
+        handler.handle(this);
+    }
+}
diff --git a/protocol/src/main/java/network/ycc/waterdog/pe/packet/PEResourceStack.java b/protocol/src/main/java/network/ycc/waterdog/pe/packet/PEResourceStack.java
new file mode 100644
index 00000000..42d63c02
--- /dev/null
+++ b/protocol/src/main/java/network/ycc/waterdog/pe/packet/PEResourceStack.java
@@ -0,0 +1,32 @@
+package network.ycc.waterdog.pe.packet;
+
+import io.netty.buffer.ByteBuf;
+
+import lombok.Data;
+import lombok.EqualsAndHashCode;
+
+import net.md_5.bungee.protocol.AbstractPacketHandler;
+import net.md_5.bungee.protocol.DefinedPacket;
+
+@Data
+@EqualsAndHashCode(callSuper = false)
+public class PEResourceStack extends DefinedPacket {
+    @Override
+    public void read(ByteBuf buf) {
+        buf.skipBytes(buf.readableBytes());
+    }
+
+    @Override
+    public void write(ByteBuf buf) {
+        buf.writeBoolean(false); // required
+        writeVarInt(buf, 0); //beh packs count
+        writeVarInt(buf, 0); //res packs count
+        writeVarInt(buf, 0); //?
+        writeVarInt(buf, 0); //?
+    }
+
+    @Override
+    public void handle(AbstractPacketHandler handler) throws Exception {
+        handler.handle(this);
+    }
+}
diff --git a/protocol/src/main/java/network/ycc/waterdog/pe/packet/PETransfer.java b/protocol/src/main/java/network/ycc/waterdog/pe/packet/PETransfer.java
new file mode 100644
index 00000000..0a5d0f6f
--- /dev/null
+++ b/protocol/src/main/java/network/ycc/waterdog/pe/packet/PETransfer.java
@@ -0,0 +1,39 @@
+package network.ycc.waterdog.pe.packet;
+
+import io.netty.buffer.ByteBuf;
+
+import lombok.AllArgsConstructor;
+import lombok.Data;
+import lombok.EqualsAndHashCode;
+import lombok.NoArgsConstructor;
+
+import net.md_5.bungee.protocol.AbstractPacketHandler;
+import net.md_5.bungee.protocol.DefinedPacket;
+
+@Data
+@NoArgsConstructor
+@AllArgsConstructor
+@EqualsAndHashCode(callSuper = false)
+public class PETransfer extends DefinedPacket {
+    String host;
+    int port;
+
+    @Override
+    public void read(ByteBuf buf)
+    {
+        host = readString(buf);
+        port = buf.readUnsignedShortLE();
+    }
+
+    @Override
+    public void write(ByteBuf buf)
+    {
+        writeString(host, buf);
+        buf.writeShortLE(port);
+    }
+
+    @Override
+    public void handle(AbstractPacketHandler handler) throws Exception {
+        //TODO: real handler to handle server drive transfer. should remember the server if we can
+    }
+}
diff --git a/proxy/pom.xml b/proxy/pom.xml
index d83cf34f..3559997d 100644
--- a/proxy/pom.xml
+++ b/proxy/pom.xml
@@ -22,6 +22,15 @@
         <maven.deploy.skip>true</maven.deploy.skip>
     </properties>
 
+    <!-- Waterdog start -->
+    <repositories>
+        <repository>
+            <id>codemc-repo</id>
+            <url>https://repo.codemc.org/repository/maven-public</url>
+        </repository>
+    </repositories>
+    <!-- Waterdog end -->
+
     <dependencies>
         <dependency>
             <groupId>com.flowpowered</groupId>
@@ -118,6 +127,29 @@
             <scope>runtime</scope>
         </dependency>
         <!-- Waterfall end -->
+
+        <!-- Waterdog start -->
+        <dependency>
+            <groupId>network.ycc</groupId>
+            <artifactId>raknet</artifactId>
+            <version>0.6-SNAPSHOT</version>
+        </dependency>
+        <dependency>
+            <groupId>io.prometheus</groupId>
+            <artifactId>simpleclient</artifactId>
+            <version>0.6.0</version>
+        </dependency>
+        <dependency>
+            <groupId>io.prometheus</groupId>
+            <artifactId>simpleclient_hotspot</artifactId>
+            <version>0.6.0</version>
+        </dependency>
+        <dependency>
+            <groupId>io.prometheus</groupId>
+            <artifactId>simpleclient_httpserver</artifactId>
+            <version>0.6.0</version>
+        </dependency>
+        <!-- Waterdog end -->
     </dependencies>
 
     <build>
diff --git a/proxy/src/main/java/net/md_5/bungee/BungeeCord.java b/proxy/src/main/java/net/md_5/bungee/BungeeCord.java
index fdc23cc1..bdfc3a3b 100644
--- a/proxy/src/main/java/net/md_5/bungee/BungeeCord.java
+++ b/proxy/src/main/java/net/md_5/bungee/BungeeCord.java
@@ -90,6 +90,10 @@ import net.md_5.bungee.protocol.packet.PluginMessage;
 import net.md_5.bungee.query.RemoteQuery;
 import net.md_5.bungee.scheduler.BungeeScheduler;
 import net.md_5.bungee.util.CaseInsensitiveMap;
+import network.ycc.raknet.RakNet;
+import network.ycc.raknet.server.RakNetServer;
+import network.ycc.waterdog.pe.PEPipelineUtils;
+import network.ycc.waterdog.pe.PERakNetMetrics;
 
 /**
  * Main BungeeCord proxy class.
@@ -339,6 +343,7 @@ public class BungeeCord extends ProxyServer
                     }
                 }
             };
+            if ( !info.isPeListener() ) { // Waterdog
             new ServerBootstrap()
                     .channel( PipelineUtils.getServerChannel() )
                     .option( ChannelOption.SO_REUSEADDR, true ) // TODO: Move this elsewhere!
@@ -347,8 +352,24 @@ public class BungeeCord extends ProxyServer
                     .group( bossEventLoopGroup, workerEventLoopGroup )
                     .localAddress( info.getHost() )
                     .bind().addListener( listener );
+            // Waterdog start
+            } else {
+                new ServerBootstrap()
+                    .channelFactory(() -> new RakNetServer(PipelineUtils.getDatagramChannel()))
+                    //.option(UnixChannelOption.SO_REUSEPORT, true)
+                    .childAttr(PipelineUtils.LISTENER, info)
+                    .option(RakNet.SERVER_ID, UUID.randomUUID().getMostSignificantBits())
+                    .option(RakNet.METRICS, PERakNetMetrics.INSTANCE)
+                    .childOption(RakNet.USER_DATA_ID, 0xFE)
+                    .handler(new PEPipelineUtils.ServerChannel(this, info))
+                    .childHandler(PEPipelineUtils.SERVER_CHILD)
+                    .group(bossEventLoopGroup, workerEventLoopGroup)
+                    .localAddress( info.getHost() )
+                    .bind().addListener( listener );
+            }
+            // Waterdog end
 
-            if ( info.isQueryEnabled() )
+            if ( info.needsRealQuery() ) // Waterdog
             {
                 ChannelFutureListener bindListener = new ChannelFutureListener()
                 {
@@ -504,7 +525,7 @@ public class BungeeCord extends ProxyServer
     @Override
     public String getName()
     {
-        return "Travertine";
+        return "Waterdog"; // Waterdog
     }
 
     @Override
@@ -665,9 +686,9 @@ public class BungeeCord extends ProxyServer
     }
 
     @Override
-    public ServerInfo constructServerInfo(String name, InetSocketAddress address, String motd, boolean restricted)
+    public ServerInfo constructServerInfo(String name, InetSocketAddress address, String motd, boolean restricted, boolean useEncap) // Waterdog
     {
-        return new BungeeServerInfo( name, address, motd, restricted );
+        return new BungeeServerInfo( name, address, motd, restricted, useEncap ); // Waterdog
     }
 
     @Override
diff --git a/proxy/src/main/java/net/md_5/bungee/BungeeServerInfo.java b/proxy/src/main/java/net/md_5/bungee/BungeeServerInfo.java
index 4c0637b9..938897fd 100644
--- a/proxy/src/main/java/net/md_5/bungee/BungeeServerInfo.java
+++ b/proxy/src/main/java/net/md_5/bungee/BungeeServerInfo.java
@@ -50,6 +50,19 @@ public class BungeeServerInfo implements ServerInfo
     @Getter
     private final Queue<DefinedPacket> packetQueue = new LinkedList<>();
 
+    // Waterdog start
+    public BungeeServerInfo(String name, InetSocketAddress address, String motd, boolean restricted) {
+        this.name = name;
+        this.address = address;
+        this.motd = motd;
+        this.restricted = restricted;
+        this.useEncap = true;
+    }
+
+    @Getter
+    private final boolean useEncap;
+    // Waterdog end
+
     @Synchronized("players")
     public void addPlayer(ProxiedPlayer player)
     {
diff --git a/proxy/src/main/java/net/md_5/bungee/ServerConnector.java b/proxy/src/main/java/net/md_5/bungee/ServerConnector.java
index fc784b0f..84e0e242 100644
--- a/proxy/src/main/java/net/md_5/bungee/ServerConnector.java
+++ b/proxy/src/main/java/net/md_5/bungee/ServerConnector.java
@@ -52,6 +52,14 @@ import net.md_5.bungee.protocol.packet.ScoreboardScore;
 import net.md_5.bungee.protocol.packet.SetCompression;
 import net.md_5.bungee.util.BufUtil;
 import net.md_5.bungee.util.QuietException;
+import network.ycc.waterdog.pe.PEEncryptionInitializer;
+import network.ycc.waterdog.pe.packet.PEEncryptionResponse;
+import network.ycc.waterdog.pe.packet.PEHandshake;
+import network.ycc.waterdog.pe.packet.PELogin;
+import network.ycc.waterdog.pe.packet.PEResourcePack;
+import network.ycc.waterdog.pe.packet.PEResourcePackResponse;
+import network.ycc.waterdog.pe.packet.PEResourceStack;
+import network.ycc.waterdog.pe.packet.PEEncryptionRequest;
 
 @RequiredArgsConstructor
 public class ServerConnector extends PacketHandler
@@ -99,7 +107,14 @@ public class ServerConnector extends PacketHandler
         Handshake originalHandshake = user.getPendingConnection().getHandshake();
         Handshake copiedHandshake = new Handshake( originalHandshake.getProtocolVersion(), originalHandshake.getHost(), originalHandshake.getPort(), 2 );
 
-        if ( BungeeCord.getInstance().config.isIpForward() )
+        // Waterdog start - PE handshake
+        if (originalHandshake instanceof PEHandshake) {
+            PEHandshake oPEHandshake = (PEHandshake) originalHandshake;
+            copiedHandshake = new PEHandshake( originalHandshake.getProtocolVersion(), originalHandshake.getHost(), originalHandshake.getPort(), 2,
+                    oPEHandshake.getUsername(), oPEHandshake.getUuid(), oPEHandshake.isAuthorized(), oPEHandshake.getClientInfo() );
+        }
+        // Waterdog end
+        if ( BungeeCord.getInstance().config.isIpForward() && target.isUseEncap()) // Waterdog
         {
             String newHost = copiedHandshake.getHost() + "\00" + user.getAddress().getHostString() + "\00" + user.getUUID();
 
@@ -143,6 +158,7 @@ public class ServerConnector extends PacketHandler
         channel.write( copiedHandshake );
 
         channel.setProtocol( Protocol.LOGIN );
+        if (!(originalHandshake instanceof PEHandshake)) // Waterdog - no LoginRequest for PE
         channel.write( new LoginRequest( user.getName() ) );
     }
 
@@ -157,6 +173,7 @@ public class ServerConnector extends PacketHandler
     {
         if ( packet.packet == null )
         {
+            if (ProtocolConstants.isPE(user.getPendingConnection().getVersion())) return; // Waterdog - weird nukkit packets, TODO: need better filtering
             throw new QuietException( "Unexpected packet received during server login process!\n" + BufUtil.dump( packet.buf, 16 ) );
         }
     }
@@ -187,6 +204,7 @@ public class ServerConnector extends PacketHandler
             user.getForgeClientHandler().resetHandshake();
         }
 
+        if (!ProtocolConstants.isPE(user.getPendingConnection().getVersion())) // Waterdog
         throw CancelSendSignal.INSTANCE;
     }
 
@@ -196,6 +214,28 @@ public class ServerConnector extends PacketHandler
         ch.setCompressionThreshold( setCompression.getThreshold() );
     }
 
+    // Waterdog start
+    @Override
+    public void handle(PEResourcePack resourcePack) throws Exception
+    {
+        ch.write(new PEResourcePackResponse(PEResourcePackResponse.STATUS_HAVE_ALL_PACKS));
+    }
+
+    @Override
+    public void handle(PEResourceStack resourceStack) throws Exception
+    {
+        ch.write(new PEResourcePackResponse(PEResourcePackResponse.STATUS_COMPLETED));
+    }
+
+    @Override
+    public void handle(PEEncryptionRequest command) throws Exception
+    {
+        ch.getHandle().pipeline().addLast(new PEEncryptionInitializer(command));
+        ch.write(new PEEncryptionResponse());
+        throw CancelSendSignal.INSTANCE;
+    }
+    // Waterdog end
+
     @Override
     public void handle(Login login) throws Exception
     {
@@ -246,6 +286,15 @@ public class ServerConnector extends PacketHandler
             Login modLogin = new Login( login.getEntityId(), login.getGameMode(), (byte) login.getDimension(), login.getDifficulty(),
                     (byte) user.getPendingConnection().getListener().getTabListSize(), login.getLevelType(), login.isReducedDebugInfo() );
 
+            // Waterdog start
+            if (login instanceof PELogin) {
+                user.unsafe().sendPacket(new PEResourcePack());
+                user.unsafe().sendPacket(new PEResourceStack());
+                modLogin = new PELogin( login.getEntityId(), login.getGameMode(), (byte) login.getDimension(), login.getDifficulty(),
+                        (byte) user.getPendingConnection().getListener().getTabListSize(), login.getLevelType(), login.isReducedDebugInfo(), ((PELogin) login).getTailPayload() );
+            }
+            // Waterdog end
+
             user.unsafe().sendPacket( modLogin );
 
             // Travertine start
diff --git a/proxy/src/main/java/net/md_5/bungee/UserConnection.java b/proxy/src/main/java/net/md_5/bungee/UserConnection.java
index 3d8b875a..a729cea7 100644
--- a/proxy/src/main/java/net/md_5/bungee/UserConnection.java
+++ b/proxy/src/main/java/net/md_5/bungee/UserConnection.java
@@ -8,6 +8,7 @@ import io.netty.bootstrap.Bootstrap;
 import io.netty.channel.Channel;
 import io.netty.channel.ChannelFuture;
 import io.netty.channel.ChannelFutureListener;
+import io.netty.channel.ChannelInboundHandlerAdapter;
 import io.netty.channel.ChannelInitializer;
 import io.netty.channel.ChannelOption;
 import io.netty.util.internal.PlatformDependent;
@@ -53,7 +54,7 @@ import net.md_5.bungee.protocol.MinecraftDecoder;
 import net.md_5.bungee.protocol.MinecraftEncoder;
 import net.md_5.bungee.protocol.PacketWrapper;
 import net.md_5.bungee.protocol.Protocol;
-import net.md_5.bungee.protocol.ProtocolConstants; // Travertine
+import net.md_5.bungee.protocol.ProtocolConstants; // Travertine, Waterdog
 import net.md_5.bungee.protocol.packet.Chat;
 import net.md_5.bungee.protocol.packet.ClientSettings;
 import net.md_5.bungee.protocol.packet.Kick;
@@ -64,6 +65,13 @@ import net.md_5.bungee.tab.ServerUnique;
 import net.md_5.bungee.tab.TabList;
 import net.md_5.bungee.util.CaseInsensitiveSet;
 import net.md_5.bungee.util.ChatComponentTransformer;
+import network.ycc.raknet.RakNet;
+import network.ycc.raknet.client.channel.RakNetClientChannel;
+import network.ycc.waterdog.pe.PECompressor;
+import network.ycc.waterdog.pe.PEDecompressor;
+import network.ycc.waterdog.pe.packet.PEHandshake;
+import protocolsupport.protocol.connection.PSInitEncapsulation;
+import network.ycc.waterdog.pe.packet.PETransfer;
 
 @RequiredArgsConstructor
 public final class UserConnection implements ProxiedPlayer
@@ -345,6 +353,16 @@ public final class UserConnection implements ProxiedPlayer
             return;
         }
 
+        // Waterdog start
+        if (ProtocolConstants.isPE(getPendingConnection().getVersion()) && getServer() != null) {
+            reconnectServer = request.getTarget();
+            InetSocketAddress vHost = getPendingConnection().getVirtualHost();
+            unsafe().sendPacket(new PETransfer(vHost.getHostString(), vHost.getPort()));
+            disconnect("PE Server Transfer");
+            return;
+        }
+        // Waterdog end
+
         pendingConnects.add( target );
 
         ChannelInitializer initializer = new ChannelInitializer()
@@ -352,10 +370,26 @@ public final class UserConnection implements ProxiedPlayer
             @Override
             protected void initChannel(Channel ch) throws Exception
             {
+                // Waterdog start
+                if (ProtocolConstants.isPE(getPendingConnection().getVersion())) {
+                    if (target.isUseEncap()) {
+                        ch.pipeline().addLast(new PSInitEncapsulation(getAddress(), false));
+                    } else {
+                        ch.pipeline().addLast(PECompressor.NAME, new PECompressor());
+                        ch.pipeline().addLast(PEDecompressor.NAME, new PEDecompressor());
+                    }
+                }
+                // Waterdog end
                 PipelineUtils.BASE.initChannel( ch );
                 ch.pipeline().addAfter( PipelineUtils.FRAME_DECODER, PipelineUtils.PACKET_DECODER, new MinecraftDecoder( Protocol.HANDSHAKE, false, getPendingConnection().getVersion(), bungee.getConfig().isAllowEmptyPackets() ) ); // Waterfall
                 ch.pipeline().addAfter( PipelineUtils.FRAME_PREPENDER, PipelineUtils.PACKET_ENCODER, new MinecraftEncoder( Protocol.HANDSHAKE, false, getPendingConnection().getVersion() ) );
                 ch.pipeline().get( HandlerBoss.class ).setHandler( new ServerConnector( bungee, UserConnection.this, target ) );
+                // Waterdog start
+                if (ProtocolConstants.isPE(getPendingConnection().getVersion()) && !target.isUseEncap()) {
+                    ch.pipeline().replace(PipelineUtils.FRAME_DECODER, PipelineUtils.FRAME_DECODER, new ChannelInboundHandlerAdapter());
+                    ch.pipeline().replace(PipelineUtils.FRAME_PREPENDER, PipelineUtils.FRAME_PREPENDER, new ChannelInboundHandlerAdapter());
+                }
+                // Waterdog end
             }
         };
         ChannelFutureListener listener = new ChannelFutureListener()
@@ -389,12 +423,24 @@ public final class UserConnection implements ProxiedPlayer
                 }
             }
         };
-        Bootstrap b = new Bootstrap()
+        Bootstrap b; if (target.isUseEncap()) { // Waterdog
+        b = new Bootstrap()
                 .channel( PipelineUtils.getChannel() )
                 .group( ch.getHandle().eventLoop() )
                 .handler( initializer )
                 .option( ChannelOption.CONNECT_TIMEOUT_MILLIS, request.getConnectTimeout() )
                 .remoteAddress( target.getAddress() );
+        // Waterdog start
+        } else {
+            b = new Bootstrap()
+                .channelFactory(() -> new RakNetClientChannel(PipelineUtils.getDatagramChannel()))
+                .group(ch.getHandle().eventLoop())
+                .handler( initializer )
+                .option(RakNet.USER_DATA_ID, 0xFE)
+                .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, request.getConnectTimeout())
+                .remoteAddress(target.getAddress());
+        }
+        // Waterdog end
         // Windows is bugged, multi homed users will just have to live with random connecting IPs
         if ( getPendingConnection().getListener().isSetLocalAddress() && !PlatformDependent.isWindows() )
         {
@@ -606,6 +652,10 @@ public final class UserConnection implements ProxiedPlayer
     {
         this.settings = settings;
         this.locale = null;
+        if (pendingConnection != null && pendingConnection.getHandshake() instanceof PEHandshake) {
+            String localString = ((PEHandshake) pendingConnection.getHandshake()).getClientInfo().get("LanguageCode").toString();
+            this.locale = Locale.forLanguageTag( localString.replace( '_', '-' ) );
+        }
     }
 
     @Override
@@ -724,6 +774,7 @@ public final class UserConnection implements ProxiedPlayer
     public void setCompressionThreshold(int compressionThreshold)
     {
         if ( ProtocolConstants.isBeforeOrEq( pendingConnection.getVersion(), ProtocolConstants.MINECRAFT_1_7_6 ) ) return; // Travertine
+        if (ProtocolConstants.isPE(getPendingConnection().getVersion())) return; // Waterdog
         if ( !ch.isClosing() && this.compressionThreshold == -1 && compressionThreshold >= 0 )
         {
             this.compressionThreshold = compressionThreshold;
diff --git a/proxy/src/main/java/net/md_5/bungee/compress/PacketDecompressor.java b/proxy/src/main/java/net/md_5/bungee/compress/PacketDecompressor.java
index 37fe6ac7..fdb26501 100644
--- a/proxy/src/main/java/net/md_5/bungee/compress/PacketDecompressor.java
+++ b/proxy/src/main/java/net/md_5/bungee/compress/PacketDecompressor.java
@@ -15,6 +15,7 @@ public class PacketDecompressor extends MessageToMessageDecoder<ByteBuf>
 {
 
     private final int compressionThreshold;
+    @Getter(value=AccessLevel.PROTECTED) // Waterdog
     private final BungeeZlib zlib = CompressFactory.zlib.newInstance();
 
     @Override
diff --git a/proxy/src/main/java/net/md_5/bungee/conf/YamlConfig.java b/proxy/src/main/java/net/md_5/bungee/conf/YamlConfig.java
index 8cceac2d..35329d94 100644
--- a/proxy/src/main/java/net/md_5/bungee/conf/YamlConfig.java
+++ b/proxy/src/main/java/net/md_5/bungee/conf/YamlConfig.java
@@ -226,8 +226,9 @@ public class YamlConfig implements ConfigurationAdapter
             String addr = get( "address", "localhost:25565", val );
             String motd = ChatColor.translateAlternateColorCodes( '&', get( "motd", "&1Just another Travertine - Forced Host", val ) );
             boolean restricted = get( "restricted", false, val );
+            boolean useEncap = get( "use_encapsulation", true, val );
             InetSocketAddress address = Util.getAddr( addr );
-            ServerInfo info = ProxyServer.getInstance().constructServerInfo( name, address, motd, restricted );
+            ServerInfo info = ProxyServer.getInstance().constructServerInfo( name, address, motd, restricted, useEncap );
             ret.put( name, info );
         }
 
@@ -272,6 +273,7 @@ public class YamlConfig implements ConfigurationAdapter
             int queryPort = get( "query_port", 25577, val );
 
             boolean proxyProtocol = get( "proxy_protocol", false, val );
+            boolean peListener = get( "pe_listener", false, val ); // Waterdog
             List<String> serverPriority = new ArrayList<>( get( "priorities", Collections.EMPTY_LIST, val ) );
 
             // Default server list migration
@@ -296,7 +298,7 @@ public class YamlConfig implements ConfigurationAdapter
             }
             set( "priorities", serverPriority, val );
 
-            ListenerInfo info = new ListenerInfo( address, motd, maxPlayers, tabListSize, serverPriority, forceDefault, forced, value.toString(), setLocalAddress, pingPassthrough, queryPort, query, proxyProtocol );
+            ListenerInfo info = new ListenerInfo( address, motd, maxPlayers, tabListSize, serverPriority, forceDefault, forced, value.toString(), setLocalAddress, pingPassthrough, queryPort, query, proxyProtocol, peListener ); // Waterdog
             ret.add( info );
         }
 
diff --git a/proxy/src/main/java/net/md_5/bungee/connection/InitialHandler.java b/proxy/src/main/java/net/md_5/bungee/connection/InitialHandler.java
index ff8a5bb5..e8cde992 100644
--- a/proxy/src/main/java/net/md_5/bungee/connection/InitialHandler.java
+++ b/proxy/src/main/java/net/md_5/bungee/connection/InitialHandler.java
@@ -72,6 +72,8 @@ import net.md_5.bungee.protocol.packet.StatusResponse;
 import net.md_5.bungee.util.BoundedArrayList;
 import net.md_5.bungee.util.BufUtil;
 import net.md_5.bungee.util.QuietException;
+import network.ycc.raknet.server.channel.RakNetChildChannel;
+import network.ycc.waterdog.pe.packet.PEHandshake;
 
 @RequiredArgsConstructor
 public class InitialHandler extends PacketHandler implements PendingConnection
@@ -356,6 +358,20 @@ public class InitialHandler extends PacketHandler implements PendingConnection
                     }
                     return;
                 }
+                // Waterdog start - condensed PE handshake
+                if (handshake instanceof PEHandshake) {
+                    PEHandshake peHandshake = (PEHandshake) handshake;
+
+                    uniqueId = peHandshake.getUuid();
+                    //TODO: loginProfile
+                    handle(new LoginRequest(peHandshake.getUsername()));
+
+                    if (isOnlineMode() && !peHandshake.isAuthorized()) {
+                        disconnect( bungee.getTranslation( "offline_mode_player" ) );
+                        break;
+                    }
+                }
+                // Waterdog end
                 break;
             default:
                 throw new IllegalArgumentException( "Cannot request protocol " + handshake.getRequestedProtocol() );
@@ -410,7 +426,7 @@ public class InitialHandler extends PacketHandler implements PendingConnection
                 {
                     return;
                 }
-                if ( onlineMode )
+                if ( onlineMode && !ProtocolConstants.isPE(getVersion()) ) // Waterdog
                 {
                     unsafe().sendPacket( request = EncryptionUtil.encryptRequest() );
                 } else
@@ -621,10 +637,17 @@ public class InitialHandler extends PacketHandler implements PendingConnection
         return ( name != null ) ? name : ( loginRequest == null ) ? null : loginRequest.getData();
     }
 
+    // Waterdog start
+    //TODO: can probably get rid of this
+    public int getDefaultVersion() {
+        return ch == null ? -1 : (ch.getHandle() instanceof RakNetChildChannel ? ProtocolConstants.MINECRAFT_1_8 : -1);
+    }
+    // Waterdog end
+
     @Override
     public int getVersion()
     {
-        return ( handshake == null ) ? -1 : handshake.getProtocolVersion();
+        return ( handshake == null ) ? getDefaultVersion() : handshake.getProtocolVersion(); // Waterdog
     }
 
     @Override
diff --git a/proxy/src/main/java/net/md_5/bungee/connection/UpstreamBridge.java b/proxy/src/main/java/net/md_5/bungee/connection/UpstreamBridge.java
index 35b9530a..2aa228a0 100644
--- a/proxy/src/main/java/net/md_5/bungee/connection/UpstreamBridge.java
+++ b/proxy/src/main/java/net/md_5/bungee/connection/UpstreamBridge.java
@@ -6,6 +6,7 @@ import com.mojang.brigadier.suggestion.Suggestion;
 import com.mojang.brigadier.suggestion.Suggestions;
 import io.github.waterfallmc.waterfall.StringUtil;
 import io.netty.channel.Channel;
+import java.net.InetSocketAddress;
 import java.util.ArrayList;
 import java.util.LinkedList;
 import java.util.List;
@@ -31,6 +32,9 @@ import net.md_5.bungee.protocol.packet.PlayerListItem;
 import net.md_5.bungee.protocol.packet.PluginMessage;
 import net.md_5.bungee.protocol.packet.TabCompleteRequest;
 import net.md_5.bungee.protocol.packet.TabCompleteResponse;
+import network.ycc.waterdog.pe.packet.PECommand;
+import network.ycc.waterdog.pe.packet.PEResourcePackResponse;
+import network.ycc.waterdog.pe.packet.PETransfer;
 
 public class UpstreamBridge extends PacketHandler
 {
@@ -129,6 +133,14 @@ public class UpstreamBridge extends PacketHandler
     @Override
     public void handle(KeepAlive alive) throws Exception
     {
+        // Waterdog start
+        if (ProtocolConstants.isPE(con.getPendingConnection().getVersion())) {
+            int newPing = (int) (alive.getRandomId() / 1000000);
+            con.getTabListHandler().onPingChange( newPing );
+            con.setPing( newPing );
+            return;
+        }
+        // Waterdog end
         if ( alive.getRandomId() == con.getServer().getSentPingId() )
         {
             int newPing = (int) ( System.currentTimeMillis() - con.getSentPingTime() );
@@ -140,6 +152,29 @@ public class UpstreamBridge extends PacketHandler
         }
     }
 
+    // Waterdog start
+    @Override
+    public void handle(PEResourcePackResponse command) throws Exception
+    {
+        throw CancelSendSignal.INSTANCE;
+    }
+    // Waterdog end
+
+    // Waterdog start
+    @Override
+    public void handle(PECommand command) throws Exception
+    {
+        //TODO: remove this hack test
+        if (command.getMessage().equals("/testtransfer")) {
+            InetSocketAddress vHost = con.getPendingConnection().getVirtualHost();
+            System.out.println("test transfer back to " + vHost);
+            con.unsafe().sendPacket(new PETransfer(vHost.getHostString(), vHost.getPort()));
+            return;
+        }
+        handle(new Chat(command.getMessage(), (byte) 0));
+    }
+    // Waterdog end
+
     @Override
     public void handle(Chat chat) throws Exception
     {
diff --git a/proxy/src/main/java/net/md_5/bungee/entitymap/EntityMap.java b/proxy/src/main/java/net/md_5/bungee/entitymap/EntityMap.java
index 7d1c05cc..24c56a35 100644
--- a/proxy/src/main/java/net/md_5/bungee/entitymap/EntityMap.java
+++ b/proxy/src/main/java/net/md_5/bungee/entitymap/EntityMap.java
@@ -27,6 +27,11 @@ public abstract class EntityMap
     // Returns the correct entity map for the protocol version
     public static EntityMap getEntityMap(int version)
     {
+        // Waterdog start
+        if (ProtocolConstants.isPE(version)) {
+            return EntityMap_PE.INSTANCE;
+        }
+        // Waterdog end
         switch ( version )
         {
             case ProtocolConstants.MINECRAFT_1_7_2:
diff --git a/proxy/src/main/java/net/md_5/bungee/entitymap/EntityMap_PE.java b/proxy/src/main/java/net/md_5/bungee/entitymap/EntityMap_PE.java
new file mode 100644
index 00000000..97dffa9e
--- /dev/null
+++ b/proxy/src/main/java/net/md_5/bungee/entitymap/EntityMap_PE.java
@@ -0,0 +1,105 @@
+package net.md_5.bungee.entitymap;
+
+import io.netty.buffer.ByteBuf;
+
+import net.md_5.bungee.protocol.DefinedPacket;
+
+import java.util.function.Consumer;
+
+public class EntityMap_PE extends EntityMap {
+
+    static final EntityMap_PE INSTANCE = new EntityMap_PE();
+
+    @Override
+    public void rewriteServerbound(ByteBuf packet, int oldId, int newId)
+    {
+
+    }
+
+    @Override
+    public void rewriteClientbound(ByteBuf from, int oldId, int newId)
+    {
+        final ByteBuf to = from.duplicate();
+        final int originalReader = from.readerIndex();
+        final int packetId = DefinedPacket.readVarInt(from);
+        final Consumer<Rewrite> act = cmd -> cmd.rewrite(from, to, oldId, newId);
+
+        to.readerIndex(to.readerIndex() - 16); //rewrite in place, but with 16 byte lead
+        to.writerIndex(to.readerIndex());
+        DefinedPacket.writeVarInt(packetId, to);
+
+        switch (packetId) {
+            case 0x12: //PLAY_ENTITY_TELEPORT
+            case 0x1B: //PLAY_ENTITY_STATUS
+            case 0x1C: //PLAY_ENTITY_EFFECT
+            case 0x1D: //PLAY_ENTITY_ATTRIBUTES
+            case 0x27: //PLAY_ENTITY_METADATA
+            case 0x28: //PLAY_ENTITY_VELOCITY
+            case 0x6F: //MOVE_ENTITY_DELTA
+                act.accept(VARLONG);
+                break;
+            case 0x0E: //PLAY_ENTITY_DESTROY
+                act.accept(SVARLONG);
+                break;
+            case 0x11: //PLAY_ENTITY_COLLECT_EFFECT
+                act.accept(VARLONG);
+                act.accept(VARLONG);
+                break;
+            case 0x29: //PLAY_ENTITY_PASSENGER
+                act.accept(SVARLONG);
+                act.accept(SVARLONG);
+                break;
+            case 0x2C: //PLAY_ENTITY_ANIMATION
+                DefinedPacket.writeSVarInt(to, DefinedPacket.readSVarInt(from));
+                act.accept(VARLONG);
+                break;
+            case 0x13: //PLAY_PLAYER_MOVE_LOOK
+                act.accept(VARLONG);
+                to.writeBytes(from, Float.BYTES * 6 + Byte.BYTES * 2);
+                act.accept(VARLONG);
+                break;
+            case 0x0D: //PLAY_ENTITY_SPAWN
+                act.accept(SVARLONG);
+                act.accept(VARLONG);
+                break;
+            case 0x0C: //PLAY_SPAWN_PLAYER
+                to.writeBytes(from, Long.BYTES * 2);
+                DefinedPacket.writeString(DefinedPacket.readString(from), to);
+                act.accept(SVARLONG);
+                act.accept(VARLONG);
+                break;
+            case 0x50: //PLAY_TRADE_UPDATE
+                to.writeBytes(from, 2);
+                DefinedPacket.writeSVarInt(to, DefinedPacket.readSVarInt(from));
+                DefinedPacket.writeSVarInt(to, DefinedPacket.readSVarInt(from));
+                DefinedPacket.writeSVarInt(to, DefinedPacket.readSVarInt(from));
+                to.writeBytes(from, 1);
+                act.accept(SVARLONG);
+                act.accept(SVARLONG);
+                break;
+            default:
+                from.readerIndex(originalReader);
+                return;
+        }
+
+        //fill in the rest
+        to.writeBytes(from);
+
+        from.readerIndex(to.readerIndex());
+        from.writerIndex(to.writerIndex());
+    }
+
+    interface Rewrite {
+        void rewrite(ByteBuf from, ByteBuf to, int oldId, int newId);
+    }
+
+    static final Rewrite VARLONG = (from, to, oldId, newId) -> {
+        final long id = DefinedPacket.readVarLong(from);
+        DefinedPacket.writeVarLong(to, id == oldId ? newId : (id == newId ? oldId : id));
+    };
+
+    static final Rewrite SVARLONG = (from, to, oldId, newId) -> {
+        final long id = DefinedPacket.readSVarLong(from);
+        DefinedPacket.writeSVarLong(to, id == oldId ? newId : (id == newId ? oldId : id));
+    };
+}
diff --git a/proxy/src/main/java/network/ycc/waterdog/pe/PECompressor.java b/proxy/src/main/java/network/ycc/waterdog/pe/PECompressor.java
new file mode 100644
index 00000000..79aa95ef
--- /dev/null
+++ b/proxy/src/main/java/network/ycc/waterdog/pe/PECompressor.java
@@ -0,0 +1,81 @@
+package network.ycc.waterdog.pe;
+
+import com.google.common.base.Preconditions;
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.ByteBufUtil;
+import io.netty.channel.ChannelFutureListener;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.ChannelOutboundHandlerAdapter;
+import io.netty.channel.ChannelPromise;
+
+import io.netty.util.ReferenceCountUtil;
+import net.md_5.bungee.compress.CompressFactory;
+import net.md_5.bungee.jni.zlib.BungeeZlib;
+import net.md_5.bungee.protocol.DefinedPacket;
+
+import java.util.zip.DataFormatException;
+import java.util.zip.Deflater;
+
+public class PECompressor extends ChannelOutboundHandlerAdapter {
+
+    public static final String NAME = "compress";
+    protected static final int MAX_POOL_BYTES = 4096;
+
+    protected final BungeeZlib zlib = CompressFactory.zlib.newInstance();
+    protected ByteBuf stashBuffer;
+
+    @Override
+    public void handlerAdded(ChannelHandlerContext ctx) {
+        zlib.init( true, Deflater.DEFAULT_COMPRESSION );
+        stashBuffer = ctx.alloc().ioBuffer(MAX_POOL_BYTES);
+    }
+
+    @Override
+    public void handlerRemoved(ChannelHandlerContext ctx) {
+        zlib.free();
+        ReferenceCountUtil.safeRelease(stashBuffer);
+    }
+
+    @Override
+    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
+        if (msg instanceof ByteBuf) {
+            final ByteBuf buf = (ByteBuf) msg;
+            if (!buf.isReadable()) {
+                buf.release();
+                return;
+            }
+            try {
+                DefinedPacket.writeVarInt(buf.readableBytes(), stashBuffer);
+                stashBuffer.writeBytes(buf);
+            } finally {
+                buf.release();
+            }
+            if (stashBuffer.readableBytes() > MAX_POOL_BYTES) {
+                flushData(ctx);
+            }
+            promise.trySuccess();
+            PERakNetMetrics.INSTANCE.outPrePacket.inc(1);
+            return;
+        }
+        super.write(ctx, msg, promise);
+    }
+
+    @Override
+    public void flush(ChannelHandlerContext ctx) throws Exception {
+        if (stashBuffer.readableBytes() > 0) {
+            flushData(ctx);
+        }
+        super.flush(ctx);
+    }
+
+    protected void flushData(ChannelHandlerContext ctx) throws DataFormatException {
+        final ByteBuf out = ctx.alloc().ioBuffer(128);
+        Preconditions.checkArgument(stashBuffer.hasMemoryAddress(), "pre-compression buffer is not direct");
+        PERakNetMetrics.INSTANCE.outPreComp.inc(stashBuffer.readableBytes());
+        zlib.process(stashBuffer, out);
+        PERakNetMetrics.INSTANCE.outPostComp.inc(out.readableBytes());
+        stashBuffer.clear();
+        ctx.write(out).addListener(ChannelFutureListener.FIRE_EXCEPTION_ON_FAILURE);
+    }
+
+}
diff --git a/proxy/src/main/java/network/ycc/waterdog/pe/PEDecompressor.java b/proxy/src/main/java/network/ycc/waterdog/pe/PEDecompressor.java
new file mode 100644
index 00000000..ab20c3c0
--- /dev/null
+++ b/proxy/src/main/java/network/ycc/waterdog/pe/PEDecompressor.java
@@ -0,0 +1,47 @@
+package network.ycc.waterdog.pe;
+
+import com.google.common.base.Preconditions;
+import io.netty.buffer.ByteBuf;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.handler.codec.MessageToMessageDecoder;
+
+import io.netty.util.ReferenceCountUtil;
+import net.md_5.bungee.compress.CompressFactory;
+import net.md_5.bungee.compress.PacketDecompressor;
+import net.md_5.bungee.jni.zlib.BungeeZlib;
+import net.md_5.bungee.protocol.DefinedPacket;
+
+import java.util.List;
+
+public class PEDecompressor extends PacketDecompressor {
+
+    public static final String NAME = "decompress";
+
+    public PEDecompressor() {
+        super(0);
+    }
+
+    @Override
+    protected void decode(ChannelHandlerContext ctx, ByteBuf buf, List<Object> list) throws Exception {
+        /*final ByteBuf tmp;
+        if (buf.hasMemoryAddress()) {
+            tmp = null;
+        } else {
+            tmp = ctx.alloc().ioBuffer(buf.readableBytes()).writeBytes(buf);
+            buf = tmp;
+        }
+        Preconditions.checkArgument(buf.hasMemoryAddress(), "Compressed buffer is not direct");*/
+        final ByteBuf data = ctx.alloc().ioBuffer(32);
+        try {
+            getZlib().process(buf, data);
+            while (data.isReadable()) {
+                list.add(data.readRetainedSlice(DefinedPacket.readVarInt(data)));
+            }
+            Preconditions.checkArgument(!data.isReadable(), "Compressed data not handled");
+        } finally {
+            ReferenceCountUtil.safeRelease(data);
+            //ReferenceCountUtil.safeRelease(tmp);
+        }
+    }
+
+}
diff --git a/proxy/src/main/java/network/ycc/waterdog/pe/PEDimSwitchLock.java b/proxy/src/main/java/network/ycc/waterdog/pe/PEDimSwitchLock.java
new file mode 100644
index 00000000..d94cb82c
--- /dev/null
+++ b/proxy/src/main/java/network/ycc/waterdog/pe/PEDimSwitchLock.java
@@ -0,0 +1,90 @@
+package network.ycc.waterdog.pe;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.channel.ChannelDuplexHandler;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.ChannelPromise;
+import io.netty.util.ReferenceCountUtil;
+
+import net.md_5.bungee.BungeeCord;
+import net.md_5.bungee.protocol.DefinedPacket;
+
+import java.util.ArrayDeque;
+import java.util.Queue;
+
+//lock outbound packet stream until we get a dim switch ack
+public class PEDimSwitchLock extends ChannelDuplexHandler {
+
+    public static final String NAME = "peproxy-dimlock";
+
+    protected static final int PLAYER_ACTION_ID = 36;
+    protected static final int EXT_PS_AWAIT_DIM_SWITCH_ACK_ID = -100;
+    protected static int DIMENSION_CHANGE_ACK = 14;
+    protected static int MAX_QUEUE_SIZE = 4096;
+
+    protected final Queue<ByteBuf> queue = new ArrayDeque<>(32);
+    protected boolean isLocked = false;
+
+    @Override
+    public void channelUnregistered(ChannelHandlerContext ctx) throws Exception {
+        super.channelUnregistered(ctx);
+        queue.forEach(ReferenceCountUtil::safeRelease);
+        queue.clear();
+    }
+
+    @Override
+    public void channelRead(ChannelHandlerContext ctx, Object msg) throws Exception {
+        if (msg instanceof ByteBuf) {
+            if(isLocked && isDimSwitchAck((ByteBuf) msg)) {
+                isLocked = false;
+                while (!queue.isEmpty() && !isLocked) {
+                    write(ctx, queue.remove(), ctx.voidPromise());
+                }
+                ctx.flush();
+            }
+        }
+        super.channelRead(ctx, msg);
+    }
+
+    @Override
+    public void write(ChannelHandlerContext ctx, Object msg, ChannelPromise promise) throws Exception {
+        if (msg instanceof ByteBuf) {
+            if (isLocked) {
+                queue.add((ByteBuf) msg);
+                promise.trySuccess();
+                if (queue.size() > MAX_QUEUE_SIZE) {
+                    BungeeCord.getInstance().getLogger().warning(
+                            "PEDimSwitchLock: queue got too large, closing connection.");
+                    ctx.channel().close();
+                }
+                return;
+            } else if (peekPacketId((ByteBuf) msg) == EXT_PS_AWAIT_DIM_SWITCH_ACK_ID) {
+                isLocked = true;
+                return;
+            }
+        }
+        super.write(ctx, msg, promise);
+    }
+
+    public static int peekPacketId(ByteBuf from) {
+        if (!from.isReadable()) {
+            return -1;
+        }
+        try {
+            return DefinedPacket.readVarInt(from.markReaderIndex());
+        } finally {
+            from.resetReaderIndex();
+        }
+    }
+
+    public static boolean isDimSwitchAck(ByteBuf data) {
+        if (peekPacketId(data) == PLAYER_ACTION_ID) {
+            final ByteBuf copy = data.duplicate();
+            DefinedPacket.readVarInt(copy);
+            DefinedPacket.readVarLong(copy); // entity id
+            return DefinedPacket.readSVarInt(copy) == DIMENSION_CHANGE_ACK;
+        }
+        return false;
+    }
+
+}
diff --git a/proxy/src/main/java/network/ycc/waterdog/pe/PEEncryptionInitializer.java b/proxy/src/main/java/network/ycc/waterdog/pe/PEEncryptionInitializer.java
new file mode 100644
index 00000000..8fa4a80b
--- /dev/null
+++ b/proxy/src/main/java/network/ycc/waterdog/pe/PEEncryptionInitializer.java
@@ -0,0 +1,99 @@
+package network.ycc.waterdog.pe;
+
+import com.nimbusds.jose.JWSObject;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.buffer.Unpooled;
+import io.netty.channel.Channel;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.ChannelInitializer;
+
+import lombok.RequiredArgsConstructor;
+
+import net.md_5.bungee.EncryptionUtil;
+import net.md_5.bungee.jni.cipher.BungeeCipher;
+import net.md_5.bungee.netty.PipelineUtils;
+import net.md_5.bungee.netty.cipher.CipherDecoder;
+import net.md_5.bungee.netty.cipher.CipherEncoder;
+
+import network.ycc.waterdog.pe.packet.PEHandshake;
+import network.ycc.waterdog.pe.packet.PEEncryptionRequest;
+
+import javax.crypto.KeyAgreement;
+import javax.crypto.spec.SecretKeySpec;
+
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+import java.security.PublicKey;
+import java.util.Base64;
+import java.util.List;
+
+@RequiredArgsConstructor
+public class PEEncryptionInitializer extends ChannelInitializer<Channel> {
+    private final PEEncryptionRequest request;
+
+    protected void initChannel(Channel ch) throws Exception {
+        final MessageDigest digest = MessageDigest.getInstance("SHA-256");
+        final JWSObject additionalData = JWSObject.parse(request.getJwtData());
+        final PublicKey publicKey = PEHandshake.parseKey(additionalData.getHeader().getX509CertURL().toString());
+        final String saltString = additionalData.getPayload().toJSONObject().getAsString("salt");
+        final KeyAgreement ka = KeyAgreement.getInstance("ECDH");
+        ka.init(PEHandshake.getKeyPair().getPrivate());
+        ka.doPhase(publicKey, true);
+        digest.update(Base64.getDecoder().decode(saltString));
+        digest.update(ka.generateSecret());
+        final byte[] keyBytes = digest.digest();
+        final SecretKeySpec serverKey = new SecretKeySpec(keyBytes, "AES");
+        ch.pipeline().addBefore(PEDecompressor.NAME, PipelineUtils.DECRYPT_HANDLER,
+                new PECipherDecoder(EncryptionUtil.getCipher(false, serverKey)));
+        ch.pipeline().addBefore(PECompressor.NAME, PipelineUtils.ENCRYPT_HANDLER,
+                new PECipherEncoder(EncryptionUtil.getCipher(true, serverKey), keyBytes));
+    }
+
+    static class PECipherDecoder extends CipherDecoder {
+        public PECipherDecoder(BungeeCipher cipher) {
+            super(cipher);
+        }
+
+        @Override
+        protected void decode(ChannelHandlerContext ctx, ByteBuf msg, List<Object> out) throws Exception {
+            super.decode(ctx, msg, out);
+            final ByteBuf data = (ByteBuf) out.get(0);
+            data.writerIndex(data.writerIndex() - 8); //ignore hash
+        }
+    }
+
+    static class PECipherEncoder extends CipherEncoder {
+        private final byte[] keyBytes;
+        private final MessageDigest digest;
+        private long counter = 0;
+
+        public PECipherEncoder(BungeeCipher cipher, byte[] keyBytes) throws NoSuchAlgorithmException {
+            super(cipher);
+            this.keyBytes = keyBytes;
+            this.digest = MessageDigest.getInstance("SHA-256");
+        }
+
+        @Override
+        protected void encode(ChannelHandlerContext ctx, ByteBuf in, ByteBuf out) throws Exception {
+            appendHash(in);
+            super.encode(ctx, in, out);
+        }
+
+        void appendHash(ByteBuf data) {
+            final ByteBuf counterBytes = Unpooled.buffer(8, 8).writeLongLE(counter++);
+            final int maxReader = data.readerIndex() + data.readableBytes();
+            while (counterBytes.isReadable()) {
+                digest.update(counterBytes.readByte());
+            }
+            for (int i = data.readerIndex() ; i < maxReader ; i++) {
+                digest.update(data.getByte(i));
+            }
+            for (byte b : keyBytes) {
+                digest.update(b);
+            }
+            data.writeBytes(digest.digest(), 0, 8);
+            digest.reset();
+        }
+    }
+}
diff --git a/proxy/src/main/java/network/ycc/waterdog/pe/PEPipelineUtils.java b/proxy/src/main/java/network/ycc/waterdog/pe/PEPipelineUtils.java
new file mode 100644
index 00000000..9941de24
--- /dev/null
+++ b/proxy/src/main/java/network/ycc/waterdog/pe/PEPipelineUtils.java
@@ -0,0 +1,77 @@
+package network.ycc.waterdog.pe;
+
+import io.netty.channel.Channel;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.ChannelInboundHandlerAdapter;
+import io.netty.channel.ChannelInitializer;
+
+import io.netty.channel.ChannelPipeline;
+import io.netty.channel.socket.DatagramPacket;
+import io.netty.util.ReferenceCountUtil;
+import lombok.RequiredArgsConstructor;
+import net.md_5.bungee.BungeeCord;
+import net.md_5.bungee.api.ProxyServer;
+import net.md_5.bungee.api.config.ListenerInfo;
+import net.md_5.bungee.netty.PipelineUtils;
+
+import net.md_5.bungee.protocol.MinecraftDecoder;
+import net.md_5.bungee.protocol.ProtocolConstants;
+import network.ycc.raknet.server.RakNetServer;
+
+import java.util.logging.Level;
+
+public class PEPipelineUtils {
+    public static final ChannelInitializer<Channel> SERVER_CHILD = new ChannelInitializer<Channel>() {
+        protected void initChannel(Channel channel) {
+            ChannelPipeline pipeline = channel.pipeline();
+            pipeline
+            .addLast(PECompressor.NAME, new PECompressor())
+            .addLast(PEDecompressor.NAME, new PEDecompressor())
+            .addLast(PEDimSwitchLock.NAME, new PEDimSwitchLock())
+            .addLast(new ChannelInboundHandlerAdapter() {
+                @Override
+                public void channelRead(ChannelHandlerContext ctx, Object msg) {
+                    if (msg instanceof network.ycc.raknet.packet.Packet) {
+                        BungeeCord.getInstance().getLogger().log(Level.FINER, "Stray raknet packet sent to a child channel handler");
+                        ReferenceCountUtil.safeRelease(msg);
+                        return;
+                    }
+                    ctx.fireChannelRead(msg);
+                }
+            })
+            .addLast(PipelineUtils.SERVER_CHILD);
+            pipeline.replace(PEPongHandler.NAME, PEPongHandler.NAME, new PEPongHandler());
+            pipeline.replace(PipelineUtils.FRAME_DECODER, PipelineUtils.FRAME_DECODER, new ChannelInboundHandlerAdapter());
+            pipeline.replace(PipelineUtils.FRAME_PREPENDER, PipelineUtils.FRAME_PREPENDER, new ChannelInboundHandlerAdapter());
+            pipeline.get(MinecraftDecoder.class).setProtocolVersion(ProtocolConstants.MINECRAFT_PE_1_8);
+        }
+    };
+
+    @RequiredArgsConstructor
+    public static final class ServerChannel extends ChannelInitializer<Channel> {
+        private final ProxyServer bungee;
+        private final ListenerInfo listener;
+
+        @Override
+        protected void initChannel(Channel channel) throws Exception {
+            channel.eventLoop().execute(() -> {
+                channel.pipeline().addLast(new ChannelInboundHandlerAdapter() {
+                    @Override
+                    public void channelRead(ChannelHandlerContext ctx, Object msg) {
+                        if (msg instanceof DatagramPacket) {
+                            bungee.getLogger().log(Level.FINER, "Stray datagram sent to server channel handler");
+                            ReferenceCountUtil.safeRelease(msg);
+                            return;
+                        }
+                        ctx.fireChannelRead(msg);
+                    }
+                });
+            });
+            channel.pipeline()
+                    .addLast(new PEProxyServerInfoHandler(bungee, listener));
+                                /*
+                                .addLast(new PEQueryHandler(bungee, listenerInfo))
+                                .addLast(new PluginLoggerInitializer());*/
+        }
+    }
+}
diff --git a/proxy/src/main/java/network/ycc/waterdog/pe/PEPongHandler.java b/proxy/src/main/java/network/ycc/waterdog/pe/PEPongHandler.java
new file mode 100644
index 00000000..4e573ed9
--- /dev/null
+++ b/proxy/src/main/java/network/ycc/waterdog/pe/PEPongHandler.java
@@ -0,0 +1,18 @@
+package network.ycc.waterdog.pe;
+
+import io.netty.buffer.Unpooled;
+import io.netty.channel.ChannelHandlerContext;
+import net.md_5.bungee.protocol.PacketWrapper;
+import net.md_5.bungee.protocol.packet.KeepAlive;
+import network.ycc.raknet.RakNet;
+import network.ycc.raknet.packet.Pong;
+import network.ycc.raknet.pipeline.PongHandler;
+
+public class PEPongHandler extends PongHandler {
+    @Override
+    protected void channelRead0(ChannelHandlerContext ctx, Pong pong) {
+        super.channelRead0(ctx, pong);
+        final RakNet.Config config = (RakNet.Config) ctx.channel().config();
+        ctx.fireChannelRead(new PacketWrapper(new KeepAlive(config.getRTT()), Unpooled.EMPTY_BUFFER));
+    }
+}
diff --git a/proxy/src/main/java/network/ycc/waterdog/pe/PEProxyServerInfoHandler.java b/proxy/src/main/java/network/ycc/waterdog/pe/PEProxyServerInfoHandler.java
new file mode 100644
index 00000000..f0053ce1
--- /dev/null
+++ b/proxy/src/main/java/network/ycc/waterdog/pe/PEProxyServerInfoHandler.java
@@ -0,0 +1,143 @@
+package network.ycc.waterdog.pe;
+
+import io.netty.channel.ChannelFutureListener;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.socket.DatagramPacket;
+import io.netty.util.ReferenceCountUtil;
+
+import net.md_5.bungee.api.ProxyServer;
+import net.md_5.bungee.api.ServerPing;
+import net.md_5.bungee.api.chat.BaseComponent;
+import net.md_5.bungee.api.chat.TextComponent;
+import net.md_5.bungee.api.config.ListenerInfo;
+import net.md_5.bungee.api.connection.PendingConnection;
+import net.md_5.bungee.api.event.ProxyPingEvent;
+import net.md_5.bungee.protocol.ProtocolConstants;
+
+import network.ycc.raknet.packet.Packet;
+import network.ycc.raknet.packet.UnconnectedPing;
+import network.ycc.raknet.packet.UnconnectedPong;
+import network.ycc.raknet.server.channel.RakNetServerChannel;
+import network.ycc.raknet.server.pipeline.UdpPacketHandler;
+
+import java.net.InetSocketAddress;
+import java.util.UUID;
+import java.util.logging.Level;
+
+public class PEProxyServerInfoHandler extends UdpPacketHandler<UnconnectedPing> {
+
+    protected final ListenerInfo listenerInfo;
+    protected final ProxyServer bungee;
+
+    public PEProxyServerInfoHandler(ProxyServer bungee, ListenerInfo listenerInfo) {
+        super(UnconnectedPing.class);
+        this.listenerInfo = listenerInfo;
+        this.bungee = bungee;
+    }
+
+    protected void handle(ChannelHandlerContext ctx, InetSocketAddress sender, UnconnectedPing ping) {
+        final RakNetServerChannel channel = (RakNetServerChannel) ctx.channel();
+        final long serverId = channel.config().getServerId();
+        final long clientTime = ping.getClientTime(); //must ditch references to ping
+        final ServerPing.Protocol protocol = new ServerPing.Protocol(
+                "", //leave version blank, we do multi-version.
+                ProtocolConstants.MINECRAFT_PE_1_10
+        );
+        final ServerPing.Players players = new ServerPing.Players(
+                listenerInfo.getMaxPlayers(), bungee.getOnlineCount(), new ServerPing.PlayerInfo[0]
+        );
+        final BaseComponent desc = new TextComponent(TextComponent.fromLegacyText(listenerInfo.getMotd().trim()));
+        final ServerPing serverPing = new ServerPing(protocol, players, desc, null);
+        final ProxyPingEvent ev = new ProxyPingEvent(new PingConnection(sender), serverPing, (event, throwable) -> {
+            final String response;
+            if (throwable != null) {
+                bungee.getLogger().log(Level.WARNING, "Failed processing PE ping:", throwable);
+                response = "";
+            } else {
+                final ServerPing result = event.getResponse();
+                response = String.join(";",
+                        "MCPE",
+                        result.getDescriptionComponent().toLegacyText().replace(";", "\\;"),
+                        String.valueOf(result.getVersion().getProtocol()),
+                        result.getVersion().getName(),
+                        String.valueOf(result.getPlayers().getOnline()),
+                        String.valueOf(result.getPlayers().getMax()),
+                        String.valueOf(serverId)
+                );
+            }
+            final Packet pong = new UnconnectedPong(clientTime, serverId, response);
+            try {
+                ctx.writeAndFlush(new DatagramPacket(pong.createData(ctx.alloc()), sender))
+                        .addListener(ChannelFutureListener.FIRE_EXCEPTION_ON_FAILURE);
+            } finally {
+                ReferenceCountUtil.release(pong);
+            }
+        });
+        bungee.getPluginManager().callEvent(ev);
+    }
+
+    protected class PingConnection implements PendingConnection {
+
+        final InetSocketAddress remoteAddress;
+
+        PingConnection(InetSocketAddress remoteAddress) {
+            this.remoteAddress = remoteAddress;
+        }
+
+        public String getName() {
+            return null;
+        }
+
+        public int getVersion() {
+            return ProtocolConstants.MINECRAFT_PE_1_11;
+        }
+
+        public InetSocketAddress getVirtualHost() {
+            return null;
+        }
+
+        public ListenerInfo getListener() {
+            return listenerInfo;
+        }
+
+        public String getUUID() {
+            return null;
+        }
+
+        public UUID getUniqueId() {
+            return null;
+        }
+
+        public void setUniqueId(UUID uuid) {}
+
+        public boolean isOnlineMode() {
+            return bungee.getConfig().isOnlineMode();
+        }
+
+        public void setOnlineMode(boolean b) {}
+
+        public boolean isLegacy() {
+            return true;
+        }
+
+        public InetSocketAddress getAddress() {
+            return remoteAddress;
+        }
+
+        public void disconnect(String s) {}
+
+        public void disconnect(BaseComponent... baseComponents) {}
+
+        public void disconnect(BaseComponent baseComponent) {}
+
+        public boolean isConnected() {
+            return false;
+        }
+
+        public Unsafe unsafe() {
+            return x -> {};
+        }
+
+    }
+
+}
diff --git a/proxy/src/main/java/network/ycc/waterdog/pe/PERakNetMetrics.java b/proxy/src/main/java/network/ycc/waterdog/pe/PERakNetMetrics.java
new file mode 100644
index 00000000..b2658d4c
--- /dev/null
+++ b/proxy/src/main/java/network/ycc/waterdog/pe/PERakNetMetrics.java
@@ -0,0 +1,105 @@
+package network.ycc.waterdog.pe;
+
+import io.prometheus.client.Counter;
+import io.prometheus.client.Gauge;
+import io.prometheus.client.Histogram;
+import io.prometheus.client.exporter.HTTPServer;
+import io.prometheus.client.hotspot.DefaultExports;
+
+import network.ycc.raknet.RakNet;
+
+import java.io.IOException;
+import java.util.concurrent.TimeUnit;
+
+public class PERakNetMetrics implements RakNet.MetricsLogger {
+    private static double sPerNs = 1.0 / TimeUnit.NANOSECONDS.convert(1, TimeUnit.SECONDS);
+
+    public static final PERakNetMetrics INSTANCE = new PERakNetMetrics();
+
+    static {
+        final int port = 1271; //Utils.getJavaPropertyValue("metrics-port", 1271, Integer::parseInt);
+        DefaultExports.initialize();
+        try {
+            new HTTPServer(port);
+        } catch (IOException e) {
+            System.err.println("Failed to start HTTP Prometheus metrics exporter on port " + port);
+            e.printStackTrace();
+        }
+    }
+
+    final Counter packetsIn = Counter.build().name("packetsIn").help("packetsIn").register();
+    final Counter framesIn = Counter.build().name("framesIn").help("framesIn").register();
+    final Counter bytesIn = Counter.build().name("bytesIn").help("bytesIn").register();
+    final Counter packetsOut = Counter.build().name("packetsOut").help("packetsOut").register();
+    final Counter framesOut = Counter.build().name("framesOut").help("framesOut").register();
+    final Counter bytesOut = Counter.build().name("bytesOut").help("bytesOut").register();
+    final Counter bytesRecalled = Counter.build().name("bytesRecalled").help("bytesRecalled").register();
+    final Counter bytesACKd = Counter.build().name("bytesACKd").help("bytesACKd").register();
+    final Counter bytesNACKd = Counter.build().name("bytesNACKd").help("bytesNACKd").register();
+    final Counter acksSent = Counter.build().name("acksSent").help("acksSent").register();
+    final Counter nacksSent = Counter.build().name("nacksSent").help("nacksSent").register();
+    final Histogram rtt = Histogram.build().name("rtt").help("RTT in seconds").register();
+    final Histogram burstTokens = Histogram.build().name("burstTokens").help("Burst tokens").register();
+    final Gauge rttGauge = Gauge.build().name("rttGauge").help("RTT in seconds").register();
+    final Counter outPrePacket = Counter.build().name("out_pre_comp_packet").help("Game packets sent (pre compression)").register();
+    public final Counter outPreComp = Counter.build().name("out_pre_comp").help("Bytes out pre-compression").register();
+    public final Counter outPostComp = Counter.build().name("out_post_comp").help("Bytes out post-compression").register();
+
+    private PERakNetMetrics() {}
+
+    public void packetsIn(int i) {
+        packetsIn.inc(i);
+    }
+
+    public void framesIn(int i) {
+        framesIn.inc(i);
+    }
+
+    public void bytesIn(int i) {
+        bytesIn.inc(i);
+    }
+
+    public void packetsOut(int i) {
+        packetsOut.inc(i);
+    }
+
+    public void framesOut(int i) {
+        framesOut.inc(i);
+    }
+
+    public void bytesOut(int i) {
+        bytesOut.inc(i);
+    }
+
+    public void bytesRecalled(int i) {
+        bytesRecalled.inc(i);
+    }
+
+    public void bytesACKd(int i) {
+        bytesACKd.inc(i);
+    }
+
+    public void bytesNACKd(int i) {
+        bytesNACKd.inc(i);
+    }
+
+    public void acksSent(int i) {
+        acksSent.inc(i);
+    }
+
+    public void nacksSent(int i) {
+        nacksSent.inc(i);
+    }
+
+    public void measureRTTns(long l) {
+        rtt.observe(l * sPerNs);
+    }
+
+    public void measureBurstTokens(int n) {
+        burstTokens.observe(n * 0.001);
+    }
+
+    public void measureRTTnsStdDev(long n) {
+        rttGauge.set(n * sPerNs);
+    }
+}
diff --git a/proxy/src/main/java/protocolsupport/protocol/connection/PSInitEncapsulation.java b/proxy/src/main/java/protocolsupport/protocol/connection/PSInitEncapsulation.java
new file mode 100644
index 00000000..331c1b29
--- /dev/null
+++ b/proxy/src/main/java/protocolsupport/protocol/connection/PSInitEncapsulation.java
@@ -0,0 +1,40 @@
+package protocolsupport.protocol.connection;
+
+import io.netty.buffer.ByteBuf;
+import io.netty.channel.ChannelHandlerContext;
+import io.netty.channel.ChannelInboundHandlerAdapter;
+
+import lombok.AllArgsConstructor;
+
+import net.md_5.bungee.protocol.DefinedPacket;
+
+import java.net.InetSocketAddress;
+
+@AllArgsConstructor
+public class PSInitEncapsulation extends ChannelInboundHandlerAdapter {
+    public static final int HANDSHAKE_ID = 0;
+    public static final int CURRENT_VERSION = 1;
+
+    private final InetSocketAddress address;
+    private final boolean compression;
+
+    @Override
+    public void channelActive(ChannelHandlerContext ctx) throws Exception {
+        final ByteBuf to = ctx.alloc().heapBuffer();
+        to.writeByte(HANDSHAKE_ID);
+        DefinedPacket.writeVarInt(to, CURRENT_VERSION);
+        if (address != null) {
+            final byte[] addr = address.getAddress().getAddress();
+            to.writeBoolean(true);
+            DefinedPacket.writeVarInt(to, addr.length);
+            to.writeBytes(addr);
+            DefinedPacket.writeVarInt(to, address.getPort());
+        } else {
+            to.writeBoolean(false);
+        }
+        to.writeBoolean(compression);
+        ctx.writeAndFlush(to);
+        super.channelActive(ctx);
+        ctx.pipeline().remove(this);
+    }
+}
-- 
2.17.2 (Apple Git-113)

